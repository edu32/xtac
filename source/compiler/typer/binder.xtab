import instantiator
import sema
import CastKind from ast
import ExitReason from ast

static moduleNameBuf = Char[ 0x400 ]

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
struct StaticContextFlag {
  const     site = CallSite*{}
  const isStatic = false // If true then {find} complains if the symbol found cannot be accessed statically.

  fn dispose(this) {
    this.site.isStatic = this.isStatic
  }
}

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
struct CallSite {
  const      pos = Pos{}
  const    scope = ast.Scope*{}
  const   binder = Binder*{}
  const   parent = CallSite*{}
  const    arity = { positional = 0, nominal = 0, variable = 0 }
  var   isStatic = false

  fn dispose(this) {
    this.binder.site = this.parent
  }

  fn setStaticContextFlag(this) {
    const previous = this.isStatic
     this.isStatic = true
    return StaticContextFlag {
          site = this,
      isStatic = previous
    }
  }

  fn throwAway(this, node)     = this.binder.throwAway(node)
  fn throwAwayList(this, list) = this.binder.throwAwayList(list)
  fn err(this, ctx, cb)        = this.binder.cberr(this.pos, ctx, cb)
  fn info(this, ctx, cb)       = this.binder.cbinfo(this.pos, ctx, cb)
  fn hasNewErrors(this, errorsLastSeen)   = this.binder.typer.errors > errorsLastSeen
  fn hasNoNewErrors(this, errorsLastSeen) = this.binder.typer.errors == errorsLastSeen
  fn e_alreadyDeclared(this, name) {
    this.err(name) with {
      println("#{it}#[%<red>] already declared in scope")
    }
  }
  fn arityError(this, type, arguments) {
    const      min = this.arity.positional
    const      max = this.arity.positional + this.arity.nominal + 
                      (0xffff if this.arity.variable else 0)
    this.err({ binder = this.binder, type = type, min = min, max = max, arguments = arguments }) with {
      if it.min == it.max {
        print("#{'ArityError'}#[%<darkred|white>]: #{it.type}\r\n\t\
          â†’ expected: #{it.min}\r\n\t\
          â†’    found: #{it.arguments.length} ")
      } else {
        print("#{'ArityError'}#[%<darkred|white>]: #{it.type}\r\n\t\
          â†’ expected: #{it.min} - #{it.max}\r\n\t\
          â†’    found: #{it.arguments.length} ")
      }
      it.binder.e_list_arguments(it.arguments)
    }
  }
  fn typeMisMatch(this, type, arguments) {
    this.err({ type = type, arguments = arguments, binder = this.binder }) with {
      print("no instance of #{it.type} matches the arguments supplied\r\n\t\
        â†’ ")
      it.binder.e_list_arguments(it.arguments)
    }
  }
}
  
//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
static    noModifiers = src.Modifiers{}
static  autoModifiers = src.Modifiers{ isAuto = true }
static constModifiers = src.Modifiers{ isConst = true }

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
import Make from make
import Evaluator from eval

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
struct ProcessModule {
  var handle = null
  var   name = Identifier*{}
}
struct Binder {
  const        typer = Typer&{}
  const          ids = Identifiers*{}
  var           site = CallSite*{}
  var            std = ast.Folder*{}
  var     sym_string = ast.Symbol*{}
  var     sym_String = ast.Symbol*{}
  var           make = Make{}
  var           eval = Evaluator{}
  var processModules = List(Void*){}

  fn dispose(this) {
    delete this.processModules
  }

  fn makeCallSite(this, scope, pos) {
    return CallSite {
          pos = pos,
        scope = scope,
       binder = this,
       parent = this.site
    }
  }

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
  fn visitMain(this) {
    const   symbol = this.typer.main
    const template = symbol.template is src.File
    const     file = symbol.instance is ast.File
    assert template && file
    this.make.ctx = this
    this.eval.ctx = this
    //println("#{'doing'}#[%<blue|white>] #{symbol.instance.type}")
    auto site = this.makeCallSite(file.scope, file.pos)
    this.site = &site
    const rsvd = this.enterScope(file.scope, ast.Scope*{})
    this.initializeProcessModules(file.pos)
    if this.findInStd(this.ids.kw_strings, this.ids.kw_string, file.scope, file.pos) && 
       this.findInStd(this.ids.kw_strings, this.ids.kw_String, file.scope, file.pos) &&
       this.bindExitReason(template, file.scope)  {
      this.visitScope(template.block, rsvd)
    }
    this.visitDeferredsOfBlock(file.scope)
    this.leaveScope(rsvd)
    //println("#{' done'}#[%<yellow|black>] #{symbol.instance.type}")
  }

  fn initializeProcessModules(this, pos) {
    const cbNeeded = 0
    if !os.EnumProcessModules(os.GetCurrentProcess(), this.processModules.items, sizeof(null) * this.processModules.length, &cbNeeded) {
      if !cbNeeded {
        this.cberr(pos, null) with {
          println("EnumProcessModules failed with #{os.GetLastError()}")
        }
        return
      }
    }
    this.processModules.setLength(cbNeeded / sizeof(null))
    if !os.EnumProcessModules(os.GetCurrentProcess(), this.processModules.items, sizeof(null) * this.processModules.length, &cbNeeded) {
      this.cberr(pos, cbNeeded) with {
        println("EnumProcessModules failed with #{os.GetLastError()} and cbNeeded = #{it}")
      }
      return
    }
    println("#{this.processModules.length} modules loaded")
    const buf = *&moduleNameBuf
    for module in this.processModules {
      const buflen = os.GetModuleBaseNameA(os.GetCurrentProcess(), module, buf.text, buf.length)
      if buflen < buf.length {
        println("\t#{string{ text = buf.text, length = buflen }}")
      }
    }
  }

  fn resolveExtern(this, ext, pos) {
    const    buf = *&moduleNameBuf
    const errors = this.typer.errors
    for module in this.processModules {
      if const  proc = os.GetProcAddress(module, ext.name.text) {
        const buflen = os.GetModuleBaseNameA(os.GetCurrentProcess(), module, buf.text, buf.length)
        if buflen < buf.length {
          ext.cfunc = proc
          ext.cdllName = this.ids.get(string{ text = buf.text, length = buflen })
        } else this.cberr(pos, ext.type) with {
          println("module name too long while resolving #{it}")
        }
      }
    }
    if !ext.cfunc {
      this.cberr(pos, ext.type) with {
        println("could not resolve the external function #{it}")
      }
    }
  }

//â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•
  fn visitFolder(this, symbol, scope, pos): ast.Symbol* {
    const folder = symbol.instance as ast.Folder*
    return symbol if folder.scope.bindingStatus.hasStarted()
    folder.scope.beginBinding()
    //println("#{'doing'}#[%<blue|white>] #{symbol.instance.type}")
    if folder.initFile {
      if const file = folder.scope.findLocal(folder.initFile.name) {
        assert file.instance == folder.initFile as ast.Node*
        this.visitFile(file, scope, pos)
      } else {
        this.cberr(pos, folder) with {
          println("cannot get init file #{it.initFile.name}#[%<red>] from \
            #{it.path}#[%<green>] although it should exist. wtf?")
        }
      }
    }
    //println("#{' done'}#[%<yellow|black>] #{symbol.instance.type}")
    folder.scope.finishBinding()
    return symbol
  }

  //-------------------------------------------------------------------------------------------------------
  fn visitFile(this, symbol, scope, pos): ast.Symbol* {
    const template = symbol.template as src.File*
    const     file = symbol.instance as ast.File*
    return symbol if file.scope.bindingStatus.hasStarted()
    //println("#{'doing'}#[%<blue|white>] #{symbol.instance.type}")
    const rsvd = this.enterScope(file.scope, ast.Scope*{})
    if this.bindExitReason(template, file.scope) {
      this.visitScope(template.block, rsvd)
    }
    this.visitDeferredsOfBlock(file.scope)
    this.leaveScope(rsvd)
    //println("#{' done'}#[%<yellow|black>] #{symbol.instance.type}")
    return symbol
  }

  //-------------------------------------------------------------------------------------------------------
  fn visitFunction(this, functionSymbol):void {
    const template = functionSymbol.template as src.Function*
    const instance = functionSymbol.instance as ast.Function*
    if template.modifiers.isAsync || template.seen.yields {
      return this.visitGenerator(functionSymbol)
    }
    //println("#{'doing'}#[%<blue|white>] #{instance.type}")
    const   errors = this.typer.errors
    const     rsvd = this.enterScope(instance.scope, ast.Scope*{})
    const fnreturn = this.beginFunction(functionSymbol)
    if errors == this.typer.errors && template.block {
      this.visitScope(template.block, rsvd)
    }
    this.insertFunctionReturn(template, instance, fnreturn)
    if instance.fnreturn.isUnknown() {
      this.err(instance.pos, "")
      assert 0
    }
    this.leaveScope(rsvd)
    //println("#{' done'}#[%<yellow|black>] #{instance.type}")
  }


  fn beginFunction(this, functionSymbol): ast.Node* {
    const template = functionSymbol.template as src.Function*
    const instance = functionSymbol.instance as ast.Function*
    const fnreturn = this.bind(template.fnreturn, instance.scope)
    
    this.bindExitReason(template, instance.scope)
    
    if fnreturn {
      instance.fnreturn = fnreturn.type
      if fnreturn.type.isNotVoid() {
        this.make.local(noModifiers, this.ids.kw_retval, fnreturn.type, instance.scope,
          fnreturn.pos, fnreturn.pos)
      }
    }
    if template.modifiers.isSynchronized {
      this.synchronizeFunction(instance)
    }
    if instance.name == this.ids.kw_dispose || instance.name == this.ids.kw_disposeWith {
      this.setReturnValueOfDisposeOrDisposeWith(template, instance, fnreturn)
    }
    return fnreturn
  }


  fn setReturnValueOfDisposeOrDisposeWith(this, template, instance, fnreturn):void {
    const first = (instance.parameters.items[0] if instance.parameters.length)
    assert first
    if fnreturn {
      if fnreturn.type != first.instance.type {
        this.cberr(fnreturn.pos, { expected = first.instance.type, found = fnreturn.type }) with {
          println("bad return type for a known function\r\n\t\
            â†’ expected: #{it.expected}\r\n\t\
            â†’    found: #{it.found}")
        }
      }
    } else {
      instance.fnreturn = first.instance.type
      const    firstPos = template.block.pos
      this.make.local(noModifiers, this.ids.kw_retval, first.instance.type, instance.scope,
        firstPos, firstPos)
    }
  }


  fn bindExitReason(this, template, scope): Bool {
    /* Translation ðŸ¡“
        var exitReason âŸµ ExitReason.Flow
    */
    const errors = this.typer.errors
    if scope.exit {
      assert scope.owner is ast.Function
    } else {
      assert scope.owner is ast.File
      scope.exit = this.make.label(this.make.exitPos(template.pos))
    }
    var pos = this.make.entryPos(scope.pos)
    if template.block {
      pos = this.make.entryPos(template.block.pos)
    }
    const local = this.make.local(
        modifiers = noModifiers,
             name = this.ids.kw_exitReason,
             type = ast.tyByte,
            scope = scope,
          namePos = pos,
              pos = pos
      )
    if local {
      scope.appendStatement(
        this.finishDefinition(
            this.make.name(local, pos),
            this.make.byte(ExitReason.Flow, pos),
            scope,
            pos
          )
        )
    }
    return errors == this.typer.errors
  }


  fn synchronizeFunction(this, function) {
    /*  Translation ðŸ¡“
          entry:
            parameter.srw.lock()
          exit:
            parameter.srw.unlock()
    */
    const  entryPos = this.make.entryPos(function.scope.pos)
    const   exitPos = this.make.exitPos(function.scope.pos)
    const     scope = function.scope
    const parameter = function.parameters.items[0] if function.parameters.length
    if !parameter {
      this.cberr(function.pos, function) with {
        println("synchronized functions must have parameters")
      }
    } else {
      var srw = this.findMember(this.make.name(parameter, entryPos), this.ids.kw_srw, scope,
        entryPos, entryPos)
      if srw {
        if const lock = this.callLock(srw, scope, entryPos) {
          scope.appendStatement(lock)
          srw = this.findMember(this.make.name(parameter, exitPos), this.ids.kw_srw, scope, exitPos, exitPos)
          if srw {
            if const unlock = this.callUnlock(srw, scope, exitPos) {
              scope.deferreds.append(unlock)
            }
          }
        }
      }
    }
  }


  fn insertReturnOfDisposeOrDisposeWith(this, template, function, fnreturn):void {
    /* Translation ðŸ¡“
        exit:
          ...
          retval âŸµ this
    */
    this.throwAway(fnreturn)

    this.takeDeferreds(function.scope)

    const lastPos = src.nlastpos(template)
    const   scope = function.scope
    if const firstParameter = (function.parameters.items[0] if function.parameters.length) {
      this.setReturnValue(function, this.make.name(firstParameter, lastPos), scope, lastPos)
    }
  }


  fn insertFunctionReturn(this, template, function, fnreturn) {
    /* Translation ðŸ¡“
        exit:
          ...
          retval âŸµ fnreturn
    */    
    if function.name == this.ids.kw_dispose || function.name == this.ids.kw_disposeWith {
      return this.insertReturnOfDisposeOrDisposeWith(template, function, fnreturn)
    }
    const   scope = function.scope
    const lastPos = src.nlastpos(template)
    const    last = scope.statements.last() as ast.Node* if scope.statements.length

    if !last || last is ast.Scope || function.fnreturn.isVoid() {
      this.takeDeferreds(scope)
      if fnreturn {
        this.setReturnValue(function, fnreturn, scope, lastPos)
        return
      }
      if function.fnreturn.isUnknown() {
        function.fnreturn = ast.tyVoid
      }
      this.setReturnValue(function, this.zero(function.fnreturn, scope, lastPos), scope, lastPos)
      return
    }

    if last is ast.Goto {
      this.takeDeferreds(scope)
      if function.fnreturn.isUnknown() {
        this.cberr(last.pos, last) with {
          println("scope's last statement is #{it.type} but the function's return has not been set")
        }
      }
      this.throwAway(fnreturn)
      return
    }

    if fnreturn {
      this.takeDeferreds(scope)
      this.setReturnValue(function, fnreturn, scope, lastPos)
      return
    }

    assert scope.statements.removeLast() as ast.Node* == last
    this.setReturnValue(function, last, scope, last.pos)
    this.takeDeferreds(scope)
  }

  //-------------------------------------------------------------------------------------------------------
  fn visitStructOrUnion(this, symbol):void {
    const template = symbol.template as src.TypeNode*
    const instance = symbol.instance as ast.TypeNode*
    //println("#{'doing'}#[%<blue|white>] #{instance.type}")
    const rsvd = this.enterScope(instance.scope, ast.Scope*{})
    if instance is ast.Struct {
      this.visitSupers(symbol)
    }
    if template.block {
      this.visitScope(template.block, rsvd)
    }
    //println("#{' done'}#[%<yellow|black>] #{instance.type}")
    this.leaveScope(rsvd)
  }

  //-------------------------------------------------------------------------------------------------------
  fn visitSupers(this, symbol):void {
    const template = symbol.template as src.Struct*
    const instance = symbol.instance as ast.Struct*
    if template.supers {
      assert !template.modifiers.isAbstract
      if const list = template.supers is src.CommaList {
        for child in list.children {
          this.visitSuper(symbol, child, symbol.scope)
        }
      } else {
        this.visitSuper(symbol, template.supers, symbol.scope)
      }
    } else if template.modifiers.isAbstract {
      this.putTypeIdField(symbol)
    }
  }


  fn visitSuper(this, symbol, template, scope) {
    const     pos = mkPos(template)
    const derived = symbol.instance as ast.Struct*
    var     value = ast.Node*{}
    var  baseName = Identifier*{}

    if const nv = template is src.NameValue {
      baseName = nv.name
      value = this.bind(nv.value, scope)
    } else {
      baseName = this.ids.kw_super
      value = this.bind(template, scope)
    }

    return if !value

    const baseSymbol = value.type.isaSymbol()
    const baseStruct = baseSymbol.instance is ast.Struct if baseSymbol && baseSymbol.instance

    if value.isNotATypeName() {
      this.cberr(pos, { derived = derived.type, base = value.type }) with {
        println("#{it.base} cannot be a super of #{it.derived} because it is not a type name")
      }
    } 
    else if !baseStruct {
      this.cberr(pos, { derived = derived.type, base = value.type }) with {
        println("#{it.base} cannot be a super of #{it.derived} because it is not a struct")
      }
    } 
    else if !this.hasTypeIdField(baseStruct.type) {
      this.cberr(pos, { derived = derived.type, base = value.type }) with {
        println("#{it.base} cannot be a super of #{it.derived} because it is not abstract")
      }
    } 
    else if this.hasCyclesInSuper(derived, baseStruct) {
      this.cberr(pos, { derived = derived.type, base = value.type }) with {
        println("#{it.base} cannot be a super of #{it.derived} because of a cyclic dependency")
      }
    } 
    else if this.make.superField(baseName, baseStruct.type, derived.scope, pos) {
      derived.typeid = this.make.typeid()
      derived.supers.append(baseStruct)
      baseStruct.derived.append(derived)
    }
    this.throwAway(value)
  }


  fn putTypeIdField(this, symbol) {
    const template = symbol.template as src.Struct*
    const instance = symbol.instance as ast.Struct*
    const      pos = mkPos(template)
    const   typeid = this.make.typeid()

    const field = this.make.field(
        modifiers = constModifiers,
             name = this.ids.kw_typeid,
            value = this.make.int(typeid, pos),
            scope = instance.scope,
              pos = pos
      )
    if field {
      instance.typeid = typeid
    }
  }

  //-------------------------------------------------------------------------------------------------------
  fn visitEnum(this, symbol):void {
    const template = symbol.template as src.Enum*
    const instance = symbol.instance as ast.Enum*
    const     rsvd = this.enterScope(instance.scope, ast.Scope*{})
    //println("#{'doing'}#[%<blue|white>] #{instance.type}")
    if template.block {
      this.visitEnumScope(template.block, rsvd)
    } else if instance.valueType.isUnknown() {
      instance.valueType = ast.tyVoid
    }
    this.leaveScope(rsvd)
    //println("#{' done'}#[%<yellow|black>] #{instance.type}")
  }

  //-------------------------------------------------------------------------------------------------------
  fn visitImport(this, symbol, scope, pos): ast.Symbol* {
    const template = symbol.template as src.Import*
    const instance = symbol.instance as ast.Import*
    var   resolved = ast.Symbol*{}

    return instance.resolved if instance.bindingStatus.isBusyOrDone()
    
    auto site = this.makeCallSite(scope, instance.pos)
    this.site = &site

    instance.bindingStatus = Status.Doing
    if template.source {
      if const source = this.resolveImport(template.source, symbol.scope) {
        resolved = this.resolveImportInSource(template.name, source, symbol.scope)
      }
    } else {
      resolved = this.resolveImport(template.name, symbol.scope)
    }
    if resolved {
      if resolved.cannotBeAccessedStatically() {
        this.cberr(instance.pos, resolved) with {
          println("cannot import non-static symbol #{it.name}#[%<red>]\r\n\t\
            â†’ #{it.type()}")
        }
      }
    }
    instance.resolved = resolved
    instance.bindingStatus = Status.Done

    if resolved {
      if resolved.getTemplate() {
        instance.bindingStatus = Status.None
      }
    } else this.cberr(pos, symbol) with {
      println("cannot resolve import #{it.name}#[%<darkred|white>]")
    }
    return resolved
  }


  fn resolveImport(this, template, scope): ast.Symbol* {
    const pos = mkPos(template)
    switch template {
      case src.MemberName {
        if const symbol = this.resolveImport(template.lhs, scope) {
          return this.resolveImportInSource(template.rhs, symbol, scope)
        }
      }
      case src.Name
        return this.resolveImportName(template.value, scope, pos)
    }
    this.cberr(pos, template) with {
      println("invalid import name: #{nameof(it)}")
    }
    return null
  }


  fn resolveImportInSource(this, template, source, scope): ast.Symbol* {
    const pos = mkPos(template)
    switch template {
      case src.MemberName {
        if const symbol = this.resolveImportInSource(template.lhs, source, scope) {
          if const rhs = template.rhs is src.Name {
            return this.resolveImportNameIn(source, rhs.value, scope, pos)
          }
          this.cberr(mkPos(template.rhs), { rhs = template.rhs, source = source}) with {
            println("cannot resolve #{nameof(it.rhs)} in #{it.source.type()}")
          }
        }
        return null
      }
      case src.Name
        return this.resolveImportNameIn(source, template.value, scope, pos)
    }
    this.cberr(pos, template) with {
      println("invalid name in 'import name from source': #{nameof(it)}")
    }
    return null
  }


  fn resolveImportName(this, name, scope, pos): ast.Symbol* {
    for var p = scope; p; p = p.parent {
      switch p.owner {
        case ast.Folder {
          if const found = p.findImportName(name) {
            if const instance = found.instance {
              switch instance {
                case ast.Import {
                  continue if instance.bindingStatus.isBusy()
                }
              }
            }
            return this.tryInstantiate(found, scope, pos)
          }
        }
      }
    }
    this.e_not_found(pos, scope.owner.type, name)
    return null
  }


  fn resolveImportNameIn(this, source, name, scope, pos): ast.Symbol* {
    const type = ast.Type.fromSymbol(source)
    if !source.instance {
      this.cberr(pos, { name = name, type = type }) with {
        println("cannot resolve import #{it.name}#[%<red>] in #{it.type}")
      }
      return null
    }
    switch source.instance {
      case folder: ast.Folder {
        assert folder.scope.bindingStatus.isBusyOrDone()
        if const found = folder.scope.findImportName(name) {
          return this.tryInstantiate(found, scope, pos)
        }
        this.e_not_found(pos, folder.type, name)
        return null
      }
      case file: ast.File {
        assert file.scope.bindingStatus.isBusyOrDone()
        if const found = file.scope.findImportName(name) {
          return this.tryInstantiate(found, scope, pos)
        }
        this.e_not_found(pos, file.type, name)
        return null
      }
      default this.cberr(pos, { name = name, type = type }) with {
        println("cannot resolve import #{it.name}#[%<red>] in #{it.type}")
      }
    }
    this.err(pos, "resolving #{name}")
    return null
  }

  //-------------------------------------------------------------------------------------------------------
  fn bindStatement(this, template, scope): ast.Node* {
    return null if !template
    switch template {
      case src.Node   assert 0
      case src.Folder assert 0
      case src.File   assert 0

      case src.Block
        return this.bindBlock(template, scope)

      case src.If
        return this.bindIf(template, scope)

      case src.For
        return this.bindFor(template, scope)

      case src.ForIn
        return this.bindForIn(template, scope)

      case src.Each
        return this.bindEach(template, scope)

      case src.Switch
        return this.bindSwitch(template, scope)

      case src.FlowControl
        this.bindFlowControl(template, scope)

      case src.Assert
        return this.bindAssert(template, scope)

      case src.Import   return null
      case src.Struct   return null // Do nothing until it is used
      case src.Union    return null
      case src.Enum     return null
      case src.Function return null
      case src.Variable {
        switch scope.owner {
          case ast.Folder   assert 0
          case ast.File     this.bindField(template, scope)
          case ast.Struct   this.bindField(template, scope)
          case ast.Union    this.bindField(template, scope)
          default {
            if template.modifiers.isStatic {
              this.bindField(template, scope)
            } else {
              return this.bindLocal(template, scope)
            }
          }
        }
      }

      case src.CommaList {
        for child in template.children {
          scope.appendStatement(this.bindStatement(child, scope))
        }
      }

      case src.NameValue
        return this.bindNameValueStmt(template, scope)

      default
        return this.bind(template, scope)
    }
    return null
  }


  fn evaluateParameter(this, template, calleeScope, site): ast.Node* {
    const statements = calleeScope.statements.length
    if const name = template is src.Name {
      if name.value == this.ids.kw_file {
        if const fileName = site.scope.parentFileName() {
          return this.finishQuoted(fileName, site.scope, site.pos)
        }
        this.cberr(mkPos(template), name) with {
          println("#{it.value}#[%<darkred|white>] does not evaluate to a file name in the calling scope")
        }
        return null
      }
      if name.value == this.ids.kw_line {
        return this.make.int(site.pos.range.start.line, site.pos)
      }
      if name.value == this.ids.kw_function {
        if const function = this.currentFunction(site.scope) {
          return this.finishQuoted(function.dotName, site.scope, site.pos)
        }
        this.cberr(mkPos(template), name) with {
          println("#{it.value}#[%<darkred|white>] does not evaluate to a function name in the calling scope")
        }
        return null
      }
    }
    const result = this.evaluate(template, calleeScope)
    if const created = calleeScope.statements.length - statements {
      this.cberr(mkPos(template), created) with {
        println("evaluation of default parameter value must not create statements in the callee scope\r\n\t\
          â†’ found: #{it}")
      }
    }
    return result
  }


  fn evaluate(this, template, scope): ast.Node* {
    auto staticContextFlag = this.site.setStaticContextFlag()
    return this.bind(template, scope)
  }


  fn bind(this, template, scope): ast.Node* {
    return null if !template
    switch template {
      case src.Node   assert 0
      case src.Folder assert 0
      case src.File   assert 0

      case src.Variable {
        if template.modifiers.isStatic {
          this.cberr(mkPos(template), template) with {
            println("static variables cannot be declared as expressions")
          }
          return null
        }
        switch scope.owner {
          case ast.Folder{}
          case ast.File{}
          case ast.Struct{}
          case ast.Union{}
          case ast.Enum{}
          default return this.bindLocal(template, scope)
        }
        this.cberr(mkPos(template), template) with {
          println("cannot declare a variable here")
        }
      }

      case src.Struct
        return this.mkTypeName(template, scope)

      case src.Union
        return this.mkTypeName(template, scope)

      case src.Enum
        return this.mkTypeName(template, scope)

      case src.Function
        return this.mkTypeName(template, scope)

      case src.Parenthesized
        return this.bindParenthesized(template, scope)

      case src.IfExpr
        return this.bindIfExpr(template, scope)

      case src.Auto
        return this.bindAuto(template, scope)

      case src.Binary
        return this.bindBinary(template, scope)

      case src.UnaryPrefix
        return this.bindUnaryPrefix(template, scope)

      case src.UnarySuffix
        return this.bindUnarySuffix(template, scope)

      case src.MemberName
        return this.bindMemberName(template, scope)

      case src.Initializer
        return this.bindInitializer(template, scope)

      case src.Call
        return this.bindCall(template, scope)

      case src.ArrayIndex
        return this.bindArrayIndex(template, scope)

      case src.Tuple
        return this.bindTuple(template, scope)

      case src.Array
        return this.bindArray(template, scope)

      case src.Object
        return this.bindObject(template, scope)

      case src.Name
        return this.bindName(template, scope)

      case src.Interpolation
        return this.bindInterpolation(template, scope)

      case src.Text
        return this.bindQuoted(template, scope)

      case src.Quoted
        return this.bindQuoted(template, scope)

      case src.Character
        return this.bindCharacter(template, scope)

      case src.Constant
        return this.bindConstant(template, scope)
    }
    this.cberr(mkPos(template), template) with {
      println("'bind' not implemented for #{nameof(it)}")
    }
    return null
  }

  //-------------------------------------------------------------------------------------------------------
  fn bindBlock(this, template, outer): ast.Scope* {
    if template.children.length == 1 {
      const node = template.children.items[0]
      switch node {
        case src.Block  return this.bindBlock(node, outer)
        case src.If     return this.bindIf(node, outer)
        case src.For    return this.bindFor(node, outer)
        case src.ForIn  return this.bindForIn(node, outer)
        case src.Each   return this.bindEach(node, outer)
        case src.Switch return this.bindSwitch(node, outer)
      }
    }
    /*  Translation ðŸ¡“
          block: {
            ...statements...
            blockExit:
              ...deferreds...
              goto exitInParent if exitReason
          }
    */
    var  block = this.make.block(outer, mkPos(template))
    const rsvd = this.enterScope(block, outer)
    this.visitScope(template, rsvd)
    this.visitDeferredsOfBlock(block)
    this.leaveScope(rsvd)
    return block
  }

  //-------------------------------------------------------------------------------------------------------
  fn bindIf(this, template, outer): ast.Scope* {
    /*  Translation ðŸ¡“
          block: {
            firstIf
            ...elseIfs...
            blockExit:
              ...deferreds
              goto exitInParent if exitReason
          }
    */
    var  block = this.make.block(outer, mkPos(template))
    const rsvd = this.enterScope(block, outer)
    var   done = false // Have we seen an non-if 'else'?

    each child in flattenIf(template) {
      switch child {
        case src.If { // 'if' or 'else if'
          if done {
            this.cberr(mkPos(child), null) with {
              println("'else if' statement cannot appear after an 'else' statement")
            }
          } else {
            this.bindElseIf(child, block)
          }
        }
        default { // 'else'
          if done {
            this.cberr(mkPos(child), null) with {
              println("multiple 'else' statements")
            }
          } else {
            this.bindElse(child, block)
            done = true
          }
        }
      }
    }
    this.visitDeferredsOfBlock(block)
    this.leaveScope(rsvd)
    return block

    fn flattenIf(template) {
      return {
        current = template,
        els = src.Node*{},
        next = fn (self): (src.Node*, Bool) {
          const current = self.current
          if current {
            if const next = current.ifalse is src.If {
              self.current = next
            } else {
              self.current = null
              self.els = current.ifalse
            }
            return (current, /* done = */ false)
          }
          if const els = self.els {
            self.els = null
            return (els, /* done = */ false)
          }
          return (null, /* done = */ true)
        }
      }
    }
  }


  fn bindElseIf(this, template, outer):void {
    /*  Translation ðŸ¡“
          block: {
            bind( condition )
            if condition {
              ...statements...
              ifExit:
                ...deferreds...
                exitReason âŸµ ExitReason.Else if !exitReason
            }
            blockExit:
              ...deferreds...
              if exitReason == ExitReason.Else {
                exitReason âŸµ ExitReason.Flow
                goto exitInGrandParent
              }
              goto exitInParent if exitReason
          }
    */
    const block = this.make.block(outer, mkPos(template))
    var  ifnode = this.make.ifStmt(block, block.pos, withExit = true, withExitInParent = true)
    const rsvd1 = this.enterScope(block, outer)

    ifnode.condition = this.bindCondition(template.condition, block)
    block.appendStatement(ifnode)
    const rsvd2 = this.enterScope(ifnode, block)
    if ifnode.condition {
      this.visitScope(template.iftrue, rsvd2)
    }
    this.visitDeferredsOfIf(ifnode)
    this.leaveScope(rsvd2)

    outer.appendStatement(block)
    this.visitDeferredsOfIfBlock(block)
    this.leaveScope(rsvd1)
  }


  fn bindElse(this, template, outer):void {
    if const els = this.bindStatement(template, outer) {
      if els !is ast.Scope {
        this.cberr(els.pos, els) with {
          println("expected scope in 'else' statement\r\n\t\
            â†’ found: #{it.type}")
        }
      }
      outer.appendStatement(els)
    }
  }

  //-------------------------------------------------------------------------------------------------------
  fn bindFor(this, template, outer): ast.Scope* {
    /*  Translation ðŸ¡“
          block: {
            bind( initializer )
            bind( condition )
            loop if condition {
              bind( increment )
              ...statements...
              loopExit:
                ...deferreds...
                if exitReason == ExitReason.Flow || exitReason == ExitReason.Continue {
                  increment
                  exitReason âŸµ ExitReason.Flow
                  goto loop
                }
                exitReason âŸµ ExitReason.Flow if exitReason == ExitReason.Break else exitReason
            }
            blockExit:
              ...deferreds...
              goto exitInParent if exitReason
          }
    */
    const block = this.make.block(outer, mkPos(template))
    const rsvd1 = this.enterScope(block, outer)
    var    loop = this.make.loop(block, block.pos)

    block.appendStatement(this.bind(template.initializer, block))

    loop.condition = this.bindCondition(template.condition, block)

    block.appendStatement(loop.entry)
    block.appendStatement(loop)
    const rsvd2 = this.enterScope(loop, block)

    const increment = this.bind(template.increment, loop)

    if loop.condition {
      this.visitScope(template.block, rsvd2)
    }
    this.visitDeferredsOfLoop(loop, increment)
    this.leaveScope(rsvd2)

    this.visitDeferredsOfBlock(block)
    this.leaveScope(rsvd1)
    return block
  }

  //-------------------------------------------------------------------------------------------------------
  fn bindForIn(this, template, outer): ast.Scope* {
    /*  Translation ðŸ¡“
          block: {
            var index âŸµ 0
            var list  âŸµ bind( template.rhs )
            loop: if index < list.length {
              var   item âŸµ list.items[index]
              ...statements...
              loopExit:
                ...deferreds...
                if exitReason == ExitReason.Flow || exitReason == ExitReason.Continue {
                  increment âŸ¶ ++index
                  exitReason âŸµ ExitReason.Flow
                  goto loop
                }
                exitReason âŸµ ExitReason.Flow if exitReason == ExitReason.Break else exitReason
            }
            blockExit:
              ...deferreds...
              goto exitInParent if exitReason
          }
    */
    const block = this.make.block(outer, mkPos(template))
    const rsvd1 = this.enterScope(block, outer)
    var    loop = this.make.loop(block, block.pos)
    var   taken = false

    auto variableNames = this.getLoopVariables(template.lhs, isForIn = true)

    if variableNames.isEmpty() {
      // Do nothing.
    } else if const list = this.bind(template.rhs, block) {
      const      listPos = *list.pos
      const   lengthBase = this.make.copyable(list, block)
      const    itemsBase = this.make.copy(lengthBase, list.pos)
      const       length = this.findMember(lengthBase, this.ids.kw_length, block, listPos, listPos)
      const        items = this.findMember(itemsBase, this.ids.kw_items, block, listPos, listPos)
      const    variables = { index = variableNames.first(), item = variableNames.last() }
      if length && items {
        // var index
        const index = this.make.local(
            modifiers = noModifiers,
                 name = variables.index.name,
                 type = ast.tyInt32,
                scope = block,
              namePos = variables.index.pos,
                  pos = variables.index.pos
          )
        if index {
          // index â† 0
          const assign = this.finishDefinition(
              this.make.name(index, variables.index.pos),
              this.make.int(0, variables.index.pos),
              block,
              variables.index.pos
            )
          block.appendStatement(assign)
          block.appendStatement(loop.entry)
          block.appendStatement(loop)
          taken = true
          const rsvd2 = this.enterScope(loop, block)

          // loop: if index < list.length
          loop.condition = this.make.binaryCondition(
               lhs = this.make.name(index, variables.index.pos),
                op = Tok.Less,
               rhs = length,
               pos = mkPos(template.lhs)
            )

          // list.items[ index ]
          const itemAtIndex = this.finishArrayIndex(
               base = items,
              index = this.make.name(index, variables.index.pos),
              scope = loop,
                pos = items.pos
            )
          if itemAtIndex {
            // var element
            const element = this.make.local(
                modifiers = noModifiers,
                     name = variables.item.name,
                     type = itemAtIndex.type,
                    scope = loop,
                  namePos = variables.item.pos,
                      pos = variables.item.pos
              )
            if element {
              // element âŸµ list.items[ index ]
              const assign2 = this.finishDefinition(
                  this.make.name(element, variables.item.pos),
                  itemAtIndex,
                  loop,
                  variables.item.pos
                )
              loop.appendStatement(assign2)
            } else {
              this.throwAway(itemAtIndex)
            }
          }
          // ++index
          const increment = this.make.preIncrement(
               value = this.make.name(index, variables.index.pos),
                 pos = variables.index.pos
            )
          this.visitScope(template.block, rsvd2)
          this.visitDeferredsOfLoop(loop, increment)
          this.leaveScope(rsvd2)
        }
      } else {        
        this.throwAway2(length, items)
      }
    }
    if !taken {
      block.appendStatement(loop.entry)
      block.appendStatement(loop)
      const rsvd2 = this.enterScope(loop, block)
      this.visitDeferredsOfLoop(loop, ast.Node*{})
      this.leaveScope(rsvd2)
    }
    this.visitDeferredsOfBlock(block)
    this.leaveScope(rsvd1)
    return block
  }


  fn bindEach(this, template, outer) {
    /*  Translation ðŸ¡“
          block: {
            var list âŸµ bind( template.rhs )
          loop: if true {
            var (..., done) âŸµ list.next()
            if done {
              exitReason âŸµ ExitReason.Break
              goto loopExit
            }
            ...statements...
          loopExit:
            ...deferreds...
            if exit exitReason == ExitReason.Continue {
              exitReason âŸµ ExitReason.Flow
              goto loop
            }
            exitReason âŸµ ExitReason.Flow if exitReason == ExitReason.Break else exitReason
          }
          blockExit:
              ...deferreds...
              goto exitInParent if exitReason
          }
    */
    const block = this.make.block(outer, mkPos(template))
    const rsvd1 = this.enterScope(block, outer)
    var    loop = this.make.loop(block, block.pos)
    var   taken = false

    auto lhsNames = this.getLoopVariables(template.lhs, isForIn = false)

    if lhsNames.isEmpty() {
      // Do nothing.
    } else if const list = this.bind(template.rhs, block) {
      var exitTaken = false
      for {
        block.appendStatement(loop.entry)
        block.appendStatement(loop)
        taken = true
        const rsvd2 = this.enterScope(loop, block)

        loop.condition = this.make.logicalIs(this.make.trueBool(list.pos), list.pos)

        // callee âŸµ list.next
        const calleeBase = this.make.copyable(list, loop)
        const  calleePos = *calleeBase.pos
        const     callee = this.findMember(calleeBase, this.ids.kw_next, loop, calleePos, calleePos)
        break if !callee

        assert (callee as ast.MemberName*).symbol.instance is ast.Field

        // call âŸµ list.next()
        const arguments = List(ast.Argument*){}
        var        call = this.finishCall(callee, arguments, loop, callee.pos)
        break if !call

        // call: T âŸµ *call: T& 
        call = this.make.directIfReference(call)
        break if !call

        const        rhs = call.type.isanObject()
        const lastIsBool = rhs.scope.symbols.last().instance.type.isBool() if rhs && rhs.scope.symbols.length
        if !rhs || rhs.scope.symbols.length != lhsNames.length || !lastIsBool {
          this.cberr(call.pos, call) with {
            println("expected rhs of 'each' statement to be a tuple of at least 2 items with the last \
              being of type #{ast.tyBool}\r\n\t\
              â†’ found: #{it.type}")
          }
          this.throwAway(call)
          break
        }

        // ( ..., done )
        const tupleItems = List(ast.Node*){}
        if !makeTupleItemsForDestructureOfEach(this, lhsNames, tupleItems, rhs, loop) {
          this.throwAway(call)
          this.throwAwayList(tupleItems)
          break
        }

        // var ( ..., done )
        const tupleSymbol = this.make.tupleFromList(tupleItems, loop, mkPos(template.lhs))

        // ( ..., done ) âŸµ call
        const destructure = this.finishDefinition(
              lhs = this.make.name(tupleSymbol, tupleSymbol.instance.pos),
              rhs = call,
            scope = loop,
              pos = tupleSymbol.instance.pos
          )
        break if !destructure
        loop.appendStatement(destructure)

        // if done { exitReason âŸµ ExitReason.Break goto loopExit }
        const doneSymbol = (tupleSymbol.instance as ast.Object*).scope.symbols.last()
        const doneMember = this.make.member(this.make.name(tupleSymbol, destructure.pos), doneSymbol, destructure.pos)
        const     ifnode = this.make.ifStmt(loop, destructure.pos, withExit = false, withExitInParent = false)
        ifnode.condition = this.make.logicalIs(doneMember, destructure.pos)
        loop.appendStatement(ifnode)
        const rsvd3 = this.enterScope(ifnode, loop)
        this.setExitReason(ExitReason.Break, ifnode, destructure.pos)
        ifnode.appendStatement(this.make.goto(loop.exit, destructure.pos))
        this.leaveScope(rsvd3 )

        this.visitScope(template.block, rsvd2)
        this.visitDeferredsOfLoop(loop, ast.Node*{})
        this.leaveScope(rsvd2)
        exitTaken = true
        break
      }
      if !exitTaken {
        const rsvd2 = this.enterScope(loop, block)
        this.visitDeferredsOfLoop(loop, ast.Node*{})
        this.leaveScope(rsvd2)
      }
    }

    if !taken {
      block.appendStatement(loop.entry)
      block.appendStatement(loop)
      const rsvd2 = this.enterScope(loop, block)
      this.visitDeferredsOfLoop(loop, ast.Node*{})
      this.leaveScope(rsvd2)
    }

    this.visitDeferredsOfBlock(block)
    this.leaveScope(rsvd1)
    return block

    fn makeTupleItemsForDestructureOfEach(binder, lhsNames, list, tuple, scope) {
      const errors = binder.typer.errors
      for i, variable in lhsNames {
        const rhs = tuple.scope.symbols.items[i].value.instance
        binder.appendTupleLocal(list, constModifiers, variable.name, rhs.type, scope,
          variable.pos, variable.pos)
      }
      return errors == binder.typer.errors
    }
  }


  fn getLoopVariables(this, template, isForIn) {
    struct LoopVariable { const name = Identifier*{} const pos = Pos{} }
    const isEach = !isForIn
    const   list = List(LoopVariable){}
    switch template {
      case src.CommaList {
        for child in template.children {
          if const name = child is src.Name {
            list.append(LoopVariable{ name = name.value, pos = mkPos(name) })
          } else {
            this.cberr(mkPos(child), child) with {
              println("expected an identifier in loop statement's variables\r\n\t\
                â†’ found: #{nameof(it)}")
            }
          }

        }
      }

      case src.Name {
        if isForIn {
          list.append(LoopVariable{ name = this.ids.random("i"), pos = mkPos(template) })
        }
        list.append(LoopVariable{ name = template.value, pos = mkPos(template) })
      }

      default {
        this.cberr(mkPos(template), template) with {
          println("invalid loop statement, expected a comma-list of 2 name or just a name")
        }
      }
    }

    return list if list.isEmpty()

    if isEach {
      list.append(LoopVariable{ name = this.ids.random("done"), pos = list.last().pos })
    }

    if isForIn {
      if list.length != 2 {
        this.cberr(mkPos(template), list) with {
          println("invalid 'for-in' statement, expected 2 names\r\n\t\
            â†’ found: #{it.length}#[%<red>]")
        }
        delete list
      }
    } else if isEach {
      if list.length < 2 {
        this.cberr(mkPos(template), list) with {
          println("invalid 'each' statement, expected at least 1 name before 'in' operator")
        }
        delete list
      }
    }

    return list
  }


  fn bindSwitch(this, template, outer): ast.Scope* {
    /* Rewrite as:
        block: {
          ...ifs..
          blockExit:
            ...deferreds...
            goto exitInParent if exitReason
        }
    */
    const block = this.make.block(outer, mkPos(template))
    const rsvd1 = this.enterScope(block, outer)
    var    done = false

    if const   condition = this.bind(template.condition, block) {
      const switchTypeId = this.hasTypeIdField(condition.type)
      const  switchValue = this.make.copyable(condition, block)
      if switchValue {
        for child in template.block.children {
          if const caseTemplate = child is src.Case {
            this.bindCase(caseTemplate, block, switchValue, switchTypeId)
            if !caseTemplate.condition {
              if done {
                this.err(mkPos(child), "multiple 'default' case statements")
              }
              done = true
            }
          } else this.cberr(mkPos(child), child) with {
            println("unexpected #{nameof(it)} in switch block")
          }
        }
        this.throwAway(switchValue)
      }
    }
    this.visitDeferredsOfBlock(block)
    this.leaveScope(rsvd1)
    return block
  }


  fn bindCase(this, template, outer, switchValue, switchTypeId):void {
    if template.condition {
      this.bindCaseWithCondition(template, outer, switchValue, switchTypeId)
    } else {
      this.bindDefault(template, outer)
    }
  }


  fn bindDefault(this, template, outer):void {
    outer.appendStatement(this.bindStatement(template.block, outer))
  }


  fn bindCaseWithCondition(this, template, outer, switchValue, switchTypeId):void {
    /* Rewrite as:
        block: {
          if condition {
            ...statements...
            ifExit:
              ...deferreds...
              exitReason âŸµ ExitReason.Else if !exitReason else exitReason
          }
          blockExit:
            ...deferreds...
            if exitReason == ExitReason.Else {
              exitReason âŸµ ExitReason.Flow
              goto exitInGrandParent
            }
            goto exitInParent if exitReason
        }
    */
    const block = this.make.block(outer, mkPos(template))
    const rsvd1 = this.enterScope(block, outer)
    var  ifnode = this.make.ifStmt(block, block.pos, withExit = true, withExitInParent = true) 

    if switchTypeId {
      this.bindCaseConditionAsTypeId(ifnode, switchValue, switchTypeId, template.condition, block)
    } else {
      this.bindCaseConditionAsValue(ifnode, switchValue, template.condition, block)
    }

    block.appendStatement(ifnode)
    const rsvd2 = this.enterScope(ifnode, block)
    if ifnode.condition {
      this.visitScope(template.block, rsvd2)
    }
    this.visitDeferredsOfIf(ifnode)
    this.leaveScope(rsvd2)

    outer.appendStatement(block)
    this.visitDeferredsOfIfBlock(block)
    this.leaveScope(rsvd1)
  }


  fn bindCaseConditionAsValue(this, ifnode, switchValue, template, scope) {
    const     pos = mkPos(template)
    const  errors = this.typer.errors
    if const list = template is src.CommaList { // case [expr (',' expr)+ ] ...
      var condition = ast.Node*{}
      for child in list.children {
        if const caseValue = this.bind(child, scope) {
          const copy = this.make.copy(switchValue, pos)
          if const comparison = this.finishCondition(copy, Tok.Equal, caseValue, scope, pos) {
            if condition {
              condition = this.finishCondition(condition, Tok.OrOr, comparison, scope, pos)
            } else {
              condition = comparison
            }
            continue
          }
        }
      }
      if errors != this.typer.errors {
        condition = this.throwAway(condition)
      } else {
        ifnode.condition = condition
      }
    } else if template is src.NameValue {
      this.err(mkPos(template), "name-value only allowed in a type-switch")
    } else if const rhs = this.bind(template, scope) {
      const copy = this.make.copy(switchValue, pos)
      ifnode.condition = this.finishCondition(copy, Tok.Equal, rhs, scope, pos)
    }
  }


  fn bindCaseConditionAsTypeId(this, ifnode, switchValue, switchTypeId, template, scope) {
    const pos = mkPos(template)
    if const list = template is src.CommaList {
      this.err(pos, "expected single value in typ-switch")
    } else if const nv = template is src.NameValue {
      if const result = this.bind(nv.value, scope) {
        const (caseValue, caseTypeId) = this.isaCaseConditionTypeValue(result, switchTypeId, pos)
        if caseValue {
          ifnode.condition = this.mkCaseConditionFromTypeValue(nv.name, switchValue, caseValue, caseTypeId,
            scope, pos)
        }
      }
    } else if const result = this.bind(template, scope) {
      const (caseValue, caseTypeId) = this.isaCaseConditionTypeValue(result, switchTypeId, pos)
      if caseValue {
        ifnode.condition = this.mkCaseConditionFromTypeValue(this.typer.emptyid, switchValue, caseValue,
          caseTypeId, scope, pos)
      }
    }
  }


  fn isaCaseConditionTypeValue(this, value, switchTypeId, pos) {
    if value.isaTypeName() && value.type.isDirect() {
      if const caseTypeId = this.hasTypeIdField(value.type) {
        if caseTypeId != switchTypeId {
          this.cberr(pos, { expected = switchTypeId.scope.owner.type, found = value.type }) with {
            println("incompatible type-switch types\r\n\t\
              â†’ expected: #{it.expected}\r\n\t\
              â†’    found: #{it.found}")
          }
        }
        return (value, caseTypeId)
      }
    } else {
      this.cberr(pos, value.type) with {
        println("expected a direct type in a type-switch. found a value of #{it}")
      }
    }
    return (this.throwAway(value), null)
  }


  fn mkCaseConditionFromTypeValue(this, name, switchValue, caseValue, caseTypeId, scope, pos) {
    const  errors = this.typer.errors
    var condition = ast.Node*{}
    const      st = caseValue.type.isaStruct()
    assert st.typeid
    if name.isEmpty() {
      if const tmp = switchValue is ast.Name {
        name = tmp.symbol.name
      }
    }
    if name.isNotEmpty() {
      // tmp: U âŸµ lhs: T as U
      // tmp.__type__id == U.__typeid__
      const   caseType = this.make.caseType(switchValue.type, caseValue.type)
      const       copy = this.make.copy(switchValue, pos)
      if  const   cast = this.make.cast(copy, caseType, pos, isImplicit = false) {
        if const local = this.make.local(constModifiers, name, cast.type, scope, pos, pos, checkShadowing = false) {
            assert local
            const lhs = this.make.name(local, pos)
            const tmp = this.make.assign(lhs, cast, pos)
          switchValue = this.make.member(tmp, caseTypeId, pos)
          const   rhs = this.make.int(st.typeid, pos)
            condition = this.finishCondition(switchValue, Tok.Equal, rhs, scope, pos)
        } else {
          this.throwAway(cast)
        }
      }
    } else {
      // lhs.__typeid__ == U.__typeid__
      const  copy = this.make.copy(switchValue, pos)
      switchValue = this.make.member(copy, caseTypeId, pos)
      const   rhs = this.make.int(st.typeid, pos)
        condition = this.finishCondition(switchValue, Tok.Equal, rhs, scope, pos)
    }
    this.throwAway(caseValue)
    return condition if errors == this.typer.errors
      else this.throwAway(condition)
  }


  fn bindAssert(this, template, outer): ast.Node* {
    /*  Translation ðŸ¡“
          assertBlock: {
            bind( condition )
            if !condition {
              ...withpart...
              ifExit: {
                ...deferreds...
                exitReason âŸµ ExitReason.Assert
                stacktrace.dump()
                assert
              }
            }
            asserBlockExit: {
              ...deferreds...
              goto exitInParent if exitReason
            }
          }
    */
    const  block = this.make.block(outer, mkPos(template))
    const  rsvd1 = this.enterScope(block, outer)
    const ifnode = this.make.ifStmt(block, block.pos, withExit = true, withExitInParent = true)

    if ifnode.condition = this.bindCondition(template.condition, block) {
       ifnode.condition = this.negateCondition(ifnode.condition)
    }
    block.appendStatement(ifnode)
    const rsvd2 = this.enterScope(ifnode, block)
    this.bindAssertMessage(template, ifnode)
    this.visitDeferredsOfAssert(ifnode)
    this.leaveScope(rsvd2)

    this.visitDeferredsOfAssertBlock(block)
    this.leaveScope(rsvd1)
    return block
  }


  fn bindAssertMessage(this, template, scope):void {
    /*  Translation ðŸ¡“
          console.stream.lock()
          file '(' start:col â€” end:col ') Â«' assert 'Â» condition'
          console.stream.unlock()
    */
    var pos = mkPos(template.condition)
    if template.isAutoCondition {
      pos = template.pos
    }    

    // console.stream
    const stream = this.findInStd(this.ids.kw_console, this.ids.kw_stream, scope, pos)
    return if !stream

    // console.stream.lock()
    scope.appendStatement(this.callLock(this.make.name(stream, pos), scope, pos))

    this.finishAssertMessage(stream, template, scope, pos)

    // console.stream.unlock()
    scope.appendStatement(this.callUnlock(this.make.name(stream, pos), scope, pos))
  }


  fn finishAssertMessage(this, stream, template, scope, pos) {
    /*  Translation ðŸ¡“
          file '(' start:col â€” end:col ') 'Â«' assert 'Â»' condition
    */
    const fileName = scope.parentFileName()
    return if !fileName

    const local = this.make.local(noModifiers, this.typer.emptyid, this.sym_string.instance.type,
      scope, pos, pos)
    const empty = this.make.local(noModifiers, this.typer.emptyid, this.sym_string.instance.type,
      scope, pos, pos)

    append(this, this.make.quoted(fileName, pos), stream, local, scope, pos)
    append(this, this.make.quoted(this.ids.get("("), pos), stream, local, scope, pos)
    format(this, this.make.int(pos.range.start.line, pos), stream, empty, scope, pos)
    append(this, this.make.quoted(this.ids.get(":"), pos), stream, local, scope, pos)
    format(this, this.make.int(pos.range.start.col, pos), stream, empty, scope, pos)
    append(this, this.make.quoted(this.ids.get("â€”"), pos), stream, local, scope, pos)
    if pos.range.start.line != pos.range.end.line {
      format(this, this.make.int(pos.range.end.line, pos), stream, empty, scope, pos)
      append(this, this.make.quoted(this.ids.get(":"), pos), stream, local, scope, pos)
    }
    format(this, this.make.int(pos.range.end.col, pos), stream, empty, scope, pos)
    append(this, this.make.quoted(this.ids.get(") Â«"), pos), stream, local, scope, pos)
    if fmtLocals(this, this.make.quoted(this.ids.get("assert"), pos), this.make.quoted(this.ids.get("%<red|white>"), pos), local, empty, scope, pos) { 
      fmt(this, local, empty, stream, scope, pos)
    }
    append(this, this.make.quoted(this.ids.get("Â» "), pos), stream, local, scope, pos)

    var str = "0"
    if !template.isAutoCondition {
      str = this.typer.sourceAt(mkPos(template.condition))
    }
    const condition = this.ids.get(str)
    append(this, this.make.quoted(condition, pos), stream, local, scope, pos)

    append(this, this.make.quoted(this.ids.get("\r\n"), pos), stream, local, scope, pos)

    if template.withPart {
      this.bindPrintArgument(template.withPart, stream, scope)
    }

    fn append(binder, value, stream, local, scope, pos): ast.Node* {
      const    callee = binder.findMember(binder.make.name(stream, pos), binder.ids.kw_append, scope, pos, pos)
      return binder.throwAway(value) if !callee
      const assign = binder.finishAssignment(binder.make.name(local, pos), value, scope, pos)
      return binder.throwAway(callee) if !assign
      const arguments = List(ast.Argument*){}
      arguments.append(binder.make.argument(binder.typer.emptyid, assign, pos))
      scope.appendStatement(binder.finishCall(callee, arguments, scope, pos))
      return null
    }

    fn format(binder, value, stream, empty, scope, pos): ast.Node* {
      // value.format ( stream, "" )
      const callee = binder.findMember(value, binder.ids.kw_format, scope, pos, pos)
      return binder.throwAway(value) if !callee
      const arguments = List(ast.Argument*){}
      arguments.append(binder.make.argument(binder.typer.emptyid, binder.make.name(stream, pos), pos))
      arguments.append(binder.make.argument(binder.typer.emptyid, binder.make.name(empty, pos), pos))
      scope.appendStatement(binder.finishCall(callee, arguments, scope, pos))
      return null
    }

    fn fmtLocals(binder, value, fmt, local, empty, scope, pos) {
      const valAssign = binder.finishAssignment(binder.make.name(local, pos), value, scope, pos)
      const fmtAssign = binder.finishAssignment(binder.make.name(empty, pos), fmt, scope, pos)
      scope.appendStatement(valAssign)
      scope.appendStatement(fmtAssign)
      return valAssign && fmtAssign
    }

    fn fmt(binder, local, empty, stream, scope, pos) {
      // value.format ( stream, fmt )
      const callee = binder.findMember(binder.make.name(local, pos), binder.ids.kw_format, scope, pos, pos)
      return if !callee
      const arguments = List(ast.Argument*){}
      arguments.append(binder.make.argument(binder.typer.emptyid, binder.make.name(stream, pos), pos))
      arguments.append(binder.make.argument(binder.typer.emptyid, binder.make.name(empty, pos), pos))
      scope.appendStatement(binder.finishCall(callee, arguments, scope, pos))
      scope.appendStatement(
          binder.finishAssignment(
              binder.make.name(empty, pos),
              binder.make.quoted(binder.ids.get(""), pos),
              scope,
              pos
            )
        )
    }
  }


  fn bindFlowControl(this, template, scope):void {
    switch template.keyword {
      case Tok.Return {
        if const function = this.currentFunction(scope) {
          if function.generator {
            this.bindGeneratorReturn(function, template, scope)
          } else {
            this.bindReturn(function, template, scope)
          }
        } else  this.cberr(mkPos(template), null) with {
          println("#{'return'}#[%<darkred|white>] statement outside of a function")
        }
      }
      case Tok.Yield {
        if const function = this.currentFunction(scope) {
          this.bindYieldStatement(function, template, scope)
        } else  this.cberr(mkPos(template), null) with {
          println("#{'yield'}#[%<darkred|white>] statement outside of a function")
        }
      }
      case Tok.YieldFrom {
        if const function = this.currentFunction(scope) {
          this.bindYieldFromStatement(function, template, scope)
        } else  this.cberr(mkPos(template), null) with {
          println("#{'yield from'}#[%<darkred|white>] statement outside of a function")
        }
      }
      case Tok.Await    this.bindAwaitStatement(template, scope)
      case Tok.Break    this.bindBreak(template, scope)
      case Tok.Continue this.bindContinue(template, scope)
      default  this.cberr(mkPos(template), template.keyword) with {
        println("flow control keyword: #{it.value()}#[%<darkred|white>] not implemented")
      }
    }
  }


  fn bindReturn(this, function, template, scope):void {
    /*  Translation ðŸ¡“
              retval âŸµ value
          exitReason âŸµ ExitReason.Return
          goto scopeExit
    */
    const pos = mkPos(template)
    if template.value {
      if const value = this.bind(template.value, scope) {
        this.setReturnValue(function, value, scope, pos)
        this.breakFlow(scope, pos)
      }
      return
    }
    if function.fnreturn.isUnknown() {
      function.fnreturn = ast.tyVoid
    }
    this.setReturnValue(function, this.zero(function.fnreturn, scope, pos), scope, pos)
    this.breakFlow(scope, pos)
  }


  fn bindBreak(this, template, scope):void {
    /*  Translation ðŸ¡“
          exitReason âŸµ ExitReason.Break
          goto scopeExit
    */
    const pos = mkPos(template)
    this.setExitReason(ExitReason.Break, scope, pos)
    this.breakFlow(scope, pos)
  }


  fn bindContinue(this, template, scope):void {
    /*  Translation ðŸ¡“
          exitReason âŸµ ExitReason.Continue
          goto scopeExit
    */
    const pos = mkPos(template)
    this.setExitReason(ExitReason.Continue, scope, pos)
    this.breakFlow(scope, pos)
  }


  fn setReturnValue(this, function, val, scope, pos):void {
    /*  Translation ðŸ¡“
              retval âŸµ value
          exitReason âŸµ ExitReason.Return
    */
    var value = this.expectValue(val, scope, initializeIfType = true)
    return if !value

    if function.fnreturn.isUnknown() {
      function.fnreturn = value.type
    } else if value = this.make.cast(value, function.fnreturn, pos, isImplicit = false) {
      // Ok.
    } else {
      return
    }
    if value.type.isVoid() {
      scope.appendStatement(value)
      this.setExitReason(ExitReason.Return, scope, pos)
    } else if const retval = this.make.retval(function, value.type, scope, pos) {
      scope.appendStatement(this.finishDefinition(retval, value, scope, pos))
      this.setExitReason(ExitReason.Return, scope, pos) // exitReason âŸµ ExitReason.Return
    } else {
      this.throwAway(value)
    }
  }


  fn setExitReason(this, value, scope, pos):void {
    /*  Translation ðŸ¡“
          exitReason âŸµ value
    */
    if const exitReason = this.make.exitReason(scope, pos) {
      scope.appendStatement(this.finishAssignment(exitReason, this.make.byte(value, pos), scope, pos))
    }
  }


  fn setExitReasonIfNone(this, value, scope, pos):void {
    /*  Translation ðŸ¡“
          exitReason âŸµ value if !exitReason else exitReason
    */
    if const exitReason = this.make.exitReason(scope, pos) {
      const        copy = this.make.copy(exitReason, pos)
      const      ifExpr = this.make.ifExpr(
          condition = this.make.logicalNot(copy, pos),
             iftrue = this.make.byte(value, pos),
                pos = pos
        )
      ifExpr.ifalse = this.make.copy(exitReason, pos)
      scope.appendStatement(
          this.finishAssignment(
              scope = scope,
                pos = pos,
                lhs = exitReason,
                rhs = ifExpr
            )
        )
    }
  }

  fn setExitReasonIf(this, value, conditionValue, scope, pos):void {
    /*  Translation ðŸ¡“
          exitReason âŸµ value if exitReason == conditionValue else exitReason
    */
    if const exitReason = this.make.exitReason(scope, pos) {
      const   condition = this.make.binaryCondition(
          pos = pos,
          lhs = this.make.copy(exitReason, pos),
           op = Tok.Equal,
          rhs = this.make.byte(conditionValue, pos)
        ) 
      const  ifExpr = this.make.ifExpr(
          condition = condition,
             iftrue = this.make.byte(value, pos),
                pos = pos
        )
      ifExpr.ifalse = this.make.copy(exitReason, pos)
      scope.appendStatement(
          this.finishAssignment(
              scope = scope,
                pos = pos,
                lhs = exitReason,
                rhs = ifExpr
            )
        )
    }
  }


  fn breakFlow(this, scope, pos):void {
    /*  Translation ðŸ¡“
          goto scopeExit
    */
    if const exit = scope.exit {
      scope.appendStatement(this.make.goto(exit, pos))
    } else this.cberr(pos, null) with {
      println("scope does not have an exit")
    }
  }


  fn exitIfReasonIs(this, value, scope, pos):void {
    /*  Translation ðŸ¡“
          goto exitInParent if exitReason == value
    */
    if const exit = scope.exitInParent {
      if const exitReason = this.make.exitReason(scope, pos) {
        scope.appendStatement(
            this.make.ifExpr(
              condition = this.make.binaryCondition(exitReason, Tok.Equal, this.make.byte(value, pos), pos),
                 iftrue = this.make.goto(exit, pos),
                    pos = pos
            )
          )
      }
    } else if scope.owner is ast.File {
      // Do nothing.  
    } else this.cberr(pos, scope) with {
      println("(exitIfReasonIs) â†’ scope does not have an exitInParent\r\n\t\
        â†’ found: #{nameof(it.owner)}")
    }
  }


  fn exitIfReasonIsNot(this, value, scope, pos):void {
    /*  Translation ðŸ¡“
          goto exitInParent if exitReason && exitReason != value
    */
    if const exit = scope.exitInParent {
      if const exitReason = this.make.exitReason(scope, pos) {
        const lhs = this.make.logicalIs(this.make.copy(exitReason, pos), pos)
        const rhs = this.make.binaryCondition(exitReason, Tok.NotEqual, this.make.byte(value, pos), pos)
        scope.appendStatement(
            this.make.ifExpr(
              condition = this.make.binaryCondition(lhs, Tok.AndAnd, rhs, pos),
                 iftrue = this.make.goto(exit, pos),
                    pos = pos
            )
          )
      }
    } else if scope.owner is ast.File {
      // Do nothing.  
    } else this.cberr(pos, scope) with {
      println("(exitIfReasonIs) â†’ scope does not have an exitInParent\r\n\t\
        â†’ found: #{nameof(it.owner)}")
    }

  }


  fn exitIfHasReason(this, scope, pos):void {
    /*  Translation ðŸ¡“
          goto exitInParent if exitReason
    */
    if const exit = scope.exitInParent {
      if const exitReason = this.make.exitReason(scope, pos) {
        scope.appendStatement(
            this.make.ifExpr(
              condition = this.make.logicalIs(exitReason, pos),
                 iftrue = this.make.goto(exit, pos),
                    pos = pos
            )
          )
      }
    } else if scope.owner is ast.File {
      // Do nothing.  
    } else this.cberr(pos, scope) with {
      println("scope does not have an exitInParent\r\n\t\
        â†’ found: #{nameof(it.owner)}")
    }
  }


  fn exitWithoutReason(this, scope, pos):void {
    /*  Translation ðŸ¡“
          goto exitInParent
    */
    if const exit = scope.exitInParent {
      scope.appendStatement(this.make.goto(exit, pos))
    } else if scope.owner is ast.File {
      // Do nothing.  
    } else this.cberr(pos, scope) with {
      println("scope does not have an exitInParent\r\n\t\
        â†’ found: #{nameof(it.owner)}")
    }
  }


  fn exitFromIfBlock(this, ifnode, pos):void {
    /*  Translation ðŸ¡“
          goto ifnode.parent.exitInParent
    */
    if const parent = ifnode.parent {
      if const exit = parent.exitInParent {
        ifnode.appendStatement(this.make.goto(exit, pos))
      } else if ifnode.owner is ast.File {
        // Do nothing.
      } else this.cberr(pos, ifnode) with {
        println("ifnode does not have an exitInParent\r\n\t\
          â†’ found: #{nameof(it.owner)}")
      }
    } else this.cberr(pos, ifnode) with {
      println("ifnode does not have parent")
    }
  }


  fn enterScope(this, scope, outer) {
    scope.beginBinding()
    return {
      scope = scope,
      outer = outer
    }
  }

  fn visitScope(this, template, rsvd):void {
    const scope = rsvd.scope
    if scope.owner.isNotAFileOrFolder() {
      this.typer.collector.visitBlockStatements(template, scope)
    }
    for child in template.children {
      scope.appendStatement(this.bindStatement(child, scope))
    }
    scope.type = ast.tyVoid
  }


  fn visitDeferredsOfBlock(this, scope):void {
    /*  Translation ðŸ¡“
        exit:
          ...deferreds...
          goto exitInParent if exitReason
    */
    this.takeDeferreds(scope)
    this.exitIfHasReason(scope, scope.exit.pos)
  }


  fn visitDeferredsOfIf(this, scope):void {
    /*  Translation ðŸ¡“
        exit:
          ...deferreds...
          exitReason âŸµ ExitReason.Else if !exitReason else exitReason
    */
    this.takeDeferreds(scope)
    this.setExitReasonIfNone(ExitReason.Else, scope, scope.exit.pos)
  }


  fn visitDeferredsOfIfBlock(this, scope):void {
    /*  Translation ðŸ¡“
        exit:
          ...deferreds...
          if exitReason == ExitReason.Else {
            exitReason âŸµ ExitReason.Flow
            goto exitInGrandParent
          }
          goto exitInParent if exitReason
    */
    const pos = scope.exit.pos
    this.takeDeferreds(scope)
    const ifnode = this.make.ifStmt(scope, pos, withExit = false, withExitInParent = false)
    scope.appendStatement(ifnode)
    const rsvd = this.enterScope(ifnode, scope)
    if const exitReason = this.make.exitReason(ifnode, pos) {
       ifnode.condition = this.make.binaryCondition(
          lhs = exitReason,
           op = Tok.Equal,
          rhs = this.make.byte(ExitReason.Else, pos),
          pos = pos
        )
      this.setExitReason(ExitReason.Flow, ifnode, pos)
      this.exitFromIfBlock(ifnode, pos)
    }
    this.exitIfHasReason(scope, pos)
    this.leaveScope(rsvd)
  }


  fn visitDeferredsOfLoop(this, loop, increment):void {
    /*  Translation ðŸ¡“
        exit:
          ...deferreds...
          if exitReason == ExitReason.Flow || exitReason == ExitReason.Continue {
            increment
            exitReason âŸµ ExitReason.Flow
            goto topOfLoop
          }
          exitReason âŸµ ExitReason.Flow if exitReason == ExitReason.Break else exitReason
    */
    this.takeDeferreds(loop)

    const    pos = loop.exit.pos
    const ifnode = this.make.ifStmt(loop, pos, withExit = false, withExitInParent = false)
    loop.appendStatement(ifnode)
    const rsvd = this.enterScope(ifnode, loop)
    if const exitReason = this.make.exitReason(ifnode, pos) {
      ifnode.condition  = this.make.binaryCondition(
          pos = pos,
           op = Tok.OrOr,
          lhs = this.make.binaryCondition(
              lhs = exitReason,
               op = Tok.Equal,
              rhs = this.make.byte(ExitReason.Flow, pos),
              pos = pos
            ),
          rhs = this.make.binaryCondition(
              lhs = this.make.copy(exitReason, pos),
               op = Tok.Equal,
              rhs = this.make.byte(ExitReason.Continue, pos),
              pos = pos
            )
        )
      ifnode.appendStatement(increment)
      this.setExitReason(ExitReason.Flow, ifnode, pos)
      ifnode.appendStatement(this.make.goto(loop.entry, pos))
    } else {
      this.throwAway(increment)
    }
    this.setExitReasonIf(ExitReason.Flow, ExitReason.Break, loop, pos)
    this.leaveScope(rsvd)
  }


  fn visitDeferredsOfAssert(this, scope):void {
    /*  exit:
          ...deferreds...
          exitReason âŸµ ExitReason.Assert
          stacktrace.dump()
          assert
    */
    const pos = scope.exit.pos
    this.takeDeferreds(scope)
    this.setExitReason(ExitReason.Assert, scope, pos)
    //this.setExitReasonIfNone(ExitReason.Assert, scope, pos)
    scope.appendStatement(this.make.assert_(pos))
  }


  fn visitDeferredsOfAssertBlock(this, scope):void {
    /*  exit:
          ...deferreds...
          goto exitInParent if exitReason && exitReason != ExitReason.Assert
    */
    const pos = scope.exit.pos
    this.takeDeferreds(scope)
    this.exitIfReasonIsNot(ExitReason.Assert, scope, pos)
    //this.exitIfHasReason(scope, pos)
  }


  fn takeDeferreds(this, scope) {
    const deferreds = scope.deferreds
    assert scope.exit
    scope.appendStatement(scope.exit)
    for var i = deferreds.length; --i >= 0; {
      const deferred = deferreds.items[i]
      switch deferred {
        case ast.Label {
          scope.appendStatement(deferred)
        }
        case ast.Call {
          scope.appendStatement(deferred)
        }
        case ast.Auto {
          scope.appendStatement(this.finishDelete(deferred.value, ast.Node*{}, scope, scope.exit.pos))
          deferred.value = null
          delete deferred
        }
        default {
          assert 0
        }
      }
    }
    deferreds.dispose()
  }


  fn leaveScope(this, rsvd) {
    const scope = rsvd.scope
    scope.finishBinding()
  }

  fn visitEnumScope(this, template, rsvd):void {
    const scope = rsvd.scope
    this.typer.collector.visitBlockStatements(template, scope)
    for statement in template.children {
      switch statement {
        case src.Import{}
        case src.Struct{}
        case src.Union{}
        case src.Enum{}
        case src.Function{}
        case src.NameValue
          this.bindEnumNameValue(statement, scope)
        case src.Name
          this.bindEnumName(statement, scope)
        default 
          this.err(mkPos(statement), "invalid statement #{nameof(statement)} in #{scope.owner.type}")
      }
    }
  }

  fn bindEnumNameValue(this, template, scope):void {
    const value = this.evaluate(template.value, scope)
    return if !value
    const def = this.make.define_(template.name, value, mkPos(template))
    const (_, duplicate) = scope.appendSymbol(def.name, this.typer.nullTemplate, def)
    if duplicate {
      this.e_exists(def.pos, template.name, duplicate)
      return
    }
    const en = scope.owner as ast.Enum*
    if en.valueType.isUnknown() {
      en.valueType = def.type
      def.type = en.type
    } else if def.value = this.make.cast(def.value, en.valueType, def.value.pos, isImplicit = false) {
      def.type = en.type
    } else {
      def.value = this.make.int(0, def.pos)
    }
  }


  fn bindEnumName(this, template, scope):void {
    const      en = scope.owner as ast.Enum*
    var lastValue = ast.Node*{}

    for var i = scope.symbols.length; --i >= 0; {
      const symbol = scope.symbols.items[i].value
      continue if !symbol.instance || symbol.instance !is ast.Define
      const nv = symbol.instance as ast.Define*
      continue if nv.type != en.type
      lastValue = nv.value
      break
    }

    var value = ast.Constant*{}
    if lastValue {
      if const num = lastValue is ast.Constant {
        if num.type.isSigned() {
          value = new ast.Constant{ pos = mkPos(template), type = en.valueType }
          value.value.i64 = num.value.i64 + 1
        } else if num.type.isUnsigned() {
          value = new ast.Constant{ pos = mkPos(template), type = en.valueType }
          value.value.u64 = num.value.u64 + 1
        }
      }
    } else if en.valueType.isIntegral() {
      value = new ast.Constant{ pos = mkPos(template), type = en.valueType }
    }

    if !value {
      this.err(mkPos(template), "enum entry '#{template.value}' must be initialized")
      return
    }
    const def = this.make.define_(template.value, value, mkPos(template))
    const (_, duplicate) = scope.appendSymbol(template.value, this.typer.nullTemplate, def)
    if duplicate {
      this.e_exists(def.pos, template.value, duplicate)
    }
    def.type = en.type
  }


  fn bindField(this, template, scope): ast.Symbol* {
    const  pos = mkPos(template)
    const name = template.name is src.Name
    if !name {
      this.cberr(mkPos(name), template) with {
        println("invalid name for a field or global\r\n\t\
          â†’ #{nameof(it)}")
      }
      return null
    }
    var value = ast.Node*{}
    if template.modifiers.isStatic {
      if scope.owner is ast.File {
        value = this.bind(template.rhs, scope)
      } else {
        value = this.evaluate(template.rhs, scope)
      }
    } else {
      value = this.evaluate(template.rhs, scope)
    }
    value = this.expectValue(value, scope, initializeIfType = true)
    return null if !value
    if template.modifiers.isStatic {
      return this.make.global(template.modifiers, name.value, value, scope, pos)
    }
    assert scope.owner.isNotAFileOrFolder()
    return this.make.field(template.modifiers, name.value, value, scope, pos)
  }


  fn bindLocal(this, template, scope): ast.Node* {
    assert !template.modifiers.isStatic
    const value = this.expectValue(this.bind(template.rhs, scope), scope, initializeIfType = true)
    return null if !value
    const name = template.name
    const  pos = mkPos(template)
    switch name {
      case src.Tuple
        return this.bindLocalDestructure(template, value, scope)

      case src.Name {
        if const symbol = this.make.local(template.modifiers, name.value, value.type, scope, mkPos(template.name), pos) {
          scope.appendStatement(
              this.make.assign(this.make.name(symbol, pos), value, pos)
            )
          return this.make.name(symbol, pos)
        }
        return this.throwAway(value)
      }
    }
    this.cberr(pos, template.name) with {
      println("invalid variable name: #{nameof(it)}")
    }
    return this.throwAway(value)
  }


  fn bindLocalDestructure(this, template, rhs, scope): ast.Node* {
    const    errors = this.typer.errors
    const modifiers = template.modifiers
    const       lhs = template.name as src.Tuple*
    const    lhsPos = mkPos(lhs)
    const lhsLength = lhs.children.length
    var        list = List(ast.Node*){}

    if const  object = rhs.type.isanObject() {
      if const tuple = object.isaTuple() {
        const rhsLength = tuple.scope.symbols.length
        if lhsLength != rhsLength {
          this.cberr(lhsPos, { lhs = lhsLength, rhs = rhsLength, type = tuple.type }) with {
            println("tuple destructure element mismatch: #{it.lhs} on lhs and #{it.rhs} on rhs (#{it.type})")
          }
          return this.throwAway(rhs)
        }
        for i, rhsItem in tuple.scope.symbols {
          const lhsItem = lhs.children.items[i]
          const    name = (lhsItem as src.Name*).value
          const     pos = mkPos(lhsItem)
          this.appendTupleLocal(list, modifiers, name, rhsItem.value.instance.type, scope, pos, pos)
        }
      } else for lhsItem in lhs.children {
        const     name = (lhsItem as src.Name*).value
        if const found = object.scope.findLocal(name) {
          const    pos = mkPos(lhsItem)
          this.appendTupleLocal(list, modifiers, name, found.type(), scope, pos, pos)
        } else {
          this.e_not_found(lhsPos, object.type, name)
        }
      }
    }

    else if const array = rhs.type.isanArray() {
      const   rhsLength = array.children.length
      if lhsLength != rhsLength { 
        this.cberr(lhsPos, { lhs = lhsLength, rhs = rhsLength, type = array.type }) with {
          println("tuple destructure element mismatch: #{it.lhs} on lhs and #{it.rhs} on rhs (#{it.type})")
        }
        return this.throwAway(rhs)
      }
      for i, rhsItem in array.children {
        const lhsItem = lhs.children.items[i]
        const    name = (lhsItem as src.Name*).value
        const     pos = mkPos(lhsItem)
        this.appendTupleLocal(list, modifiers, name, rhsItem.type, scope, pos, pos)
      }
    }

    else if const fixed = rhs.type.isaFixedArray() {
      const   rhsLength = fixed.length
      if lhsLength != rhsLength { 
        this.cberr(lhsPos, { lhs = lhsLength, rhs = rhsLength, type = fixed.type }) with {
          println("tuple destructure element mismatch: #{it.lhs} on lhs and #{it.rhs} on rhs (#{it.type})")
        }
        return this.throwAway(rhs)
      }
      for lhsItem in lhs.children {
        const name = (lhsItem as src.Name*).value
        const  pos = mkPos(lhsItem)
        this.appendTupleLocal(list, modifiers, name, fixed.element, scope, pos, pos)
      }
    }

    else if const symbol = rhs.type.isaSymbol() {
      if symbol.instance && symbol.instance is ast.Struct {
        const st = symbol.instance as ast.Struct*        
        for lhsItem in lhs.children {
          const       name = (lhsItem as src.Name*).value
          if const   found = st.scope.findLocal(name) {
            if const field = found.instance is ast.Field {
              const    pos = mkPos(lhsItem)
              this.appendTupleLocal(list, modifiers, name, field.type, scope, pos, pos)
            } else {
              this.cberr(lhsPos, { name = name, type = st.type, found = found.type() }) with {
                println("#{it.name}#[%<darkred|white>]: #{it.found} of #{it.type} is not a \
                  non-static field and cannot therefore be used in tuple destructure")
              }
            }
          } else {
            this.e_not_found(lhsPos, st.type, name)
          }
        }
      } else {
        return this.throwAway(rhs)
      }
    }

    else {
      this.cberr(lhsPos, rhs.type) with {
        println("cannot destructure #{it}")
      }
      return this.throwAway(rhs)
    }
    if errors != this.typer.errors {
      this.throwAwayList(list)
      return this.throwAway(rhs)
    }
    assert list.isNotEmpty()
    const templatePos = mkPos(template)
    const      symbol = this.make.tupleFromList(list, scope, mkPos(template.name))
    const destructure = this.finishDefinition(
          lhs = this.make.name(symbol, templatePos),
          rhs = rhs,
        scope = scope,
          pos = templatePos
      )
    if destructure {
      scope.appendStatement(destructure)
      return this.make.name(symbol, lhsPos)
    }
    return this.throwAway(rhs)
  }


  fn appendTupleLocal(this, list, modifiers, name, type, scope, namePos, pos) {
    if const symbol = this.make.local(modifiers, name, type, scope, namePos, pos) {
      list.append(this.make.name(symbol, pos))
    }   
  }


  fn bindInitializer(this, template, scope): ast.Node* {
    const name = this.bind(template.name, scope)
    return null if !name

    if name.isaTypeName() || name.isaCallBack() {
      const arguments = this.bindInitializerArguments(template.arguments, scope)
      if arguments.isEmpty() && this.hasChildren(template.arguments) {
        return this.throwAway(name)
      }
      const result = this.finishInitializer(name.type, arguments, scope, name.pos, mkPos(template))
      this.throwAway(name)
      return result
    }
    this.cberr(name.pos, name) with {
      println("expected a typename in object initializer name, not a value of #{it.type}\r\n\t\
        â†’ #{nameof(it)}")
    }
    return this.throwAway(name)
  }


  fn bindInitializerArguments(this, template, scope) {
    const  errors = this.typer.errors
    var arguments = List(ast.InitializerArgument*){}
    if this.hasChildren(template) {
      for v in template.children {
        const nv = v.value
        if const value = this.bind(nv.value, scope) {
          arguments.append(this.make.initializerArgument(nv.name, value, value.type, mkPos(nv)))
          /*if const ref = this.make.referenceIfNotLoadable(value) {
            arguments.append(this.make.initializerArgument(nv.name, ref, ref.type, mkPos(nv)))
          }*/
        }
      }
    }
    if errors != this.typer.errors {
      this.throwAwayList(arguments)
    }
    return arguments
  }


  fn bindCall(this, template, scope): ast.Node* {
    const                     pos = mkPos(template)
    const (result, isanIntrinsic) = this.bindIntrinsic(template, scope, pos)
    if isanIntrinsic {
      return result
    }
    const arguments = this.bindCallArguments(template.arguments, scope)
    if arguments.isEmpty() && this.hasChildren(template.arguments) {
      return null
    }
    if const callee = this.bind(template.name, scope) {
      return this.finishCall(callee, arguments, scope, pos)
    }
    return this.throwAwayList(arguments)
  }


  fn bindCallArguments(this, template, scope) {
    const  errors = this.typer.errors
    var arguments = List(ast.Argument*){}
    if this.hasChildren(template) {
      for child in template.children {
        if const argument = this.bindArgument(child, scope) {
          arguments.append(argument)
        }
      }
      if errors != this.typer.errors {
        this.throwAwayList(arguments)
      }
    }
    return arguments
  }


  fn finishCall(this, callee, arguments, scope, posval): ast.Node* {
    const pos = *posval
    if callee.type.isaBuiltin() {
      return this.finishCallToBuiltin(callee, arguments, scope, pos)
    }
    auto site = this.makeCallSite(scope, pos)
    this.site = &site
    const (name, type) = instantiator.call(site, callee, arguments)
    return null if type.isUnknown()
    const      symbol = type.isaSymbol()
    if const function = symbol.instance is ast.Function {
      const  fnreturn = this.getFnReturnFrom(function, pos)
      if fnreturn.isKnown() {
        if name {
          return this.make.call(name, arguments, fnreturn, pos)
        }
        return this.make.call(this.make.name(symbol, site.pos), arguments, fnreturn, pos)
      }
    } else if name {
      this.cberr(pos, type) with {
        println("finishCall: #{it}")
      }
    } else {
      this.throwAwayList(arguments)
      return this.make.name(symbol, pos)
    }
    this.throwAway(name)
    return this.throwAwayList(arguments)
  }


  fn finishOperator(this, name, rhs, scope, pos): ast.Node* {
    const   namePos = *name.pos
    const arguments = List(ast.Argument*){}
    if rhs {
      const argument = this.make.argument(this.typer.emptyid, rhs, rhs.pos)
      arguments.append(argument)
    }
    auto site = this.makeCallSite(scope, name.pos)
    this.site = &site
    const (indirect, type) = instantiator.call(site, name, arguments)
    return null if type.isUnknown()
    if indirect {
      assert 0
    }
    const symbol = type.isaSymbol()
    if const function = symbol.instance is ast.Function {
      const  fnreturn = this.getFnReturnFrom(function, namePos)
      if fnreturn.isKnown() {
        return this.make.call(this.make.name(symbol, namePos), arguments, fnreturn,  pos)
      }
    } else {
      this.cberr(pos, type) with {
        println("invalid operator type #{it}")
      }
    }
    return this.throwAwayList(arguments)
  }


  fn finishCallToBuiltin(this, callee, arguments, scope, posval): ast.Node* {
    const type = *callee.type
    const  pos = *posval
    if callee.isNotATypeName() {
      this.cberr(pos, type) with {
        println("expected a value of type #{it}")
      }
      this.throwAway(callee)
      return this.throwAwayList(arguments)
    }
    this.throwAway(callee)
    if arguments.isEmpty() { // T()
      const immediate = Immediate{}
      return this.make.constant(immediate, type, pos)
    }
    if arguments.length != 1 {
      this.cberr(pos, { type = type, arguments = arguments }) with {
        println("invalid arguments for parenthesized cast for #{it.type}\r\n\t\
          â†’ expected: 1 argument\r\n\t\
          â†’    found: #{it.arguments.length}")
      }
      return this.throwAwayList(arguments)
    }      
    const argument = arguments.items[0]
    if argument.value = this.make.cast(argument.value, type, pos, isImplicit = false) {
      const value = argument.value
      argument.value = null
      this.throwAwayList(arguments)
      return value
    }
    return this.throwAwayList(arguments)
  }


  fn bindIntrinsic(this, template, scope, pos): (ast.Node*, Bool) {
    if const name = template.name is src.Name {
      const         ids = this.ids
      var        result = ast.Node*{}
      var isanIntrinsic = true
      switch name.value {
        case ids.kw_atomic_subtract, ids.kw_atomic_add
          result = this.bindAtomiSubtractOrAdd(name.value, template.arguments, scope, pos)

        case ids.kw_atomic_decrement, ids.kw_atomic_increment
          result = this.bindAtomicDecrementOrIncrement(name.value, template.arguments, scope, pos)

        case ids.kw_atomic_pause
          result = this.bindAtomicPause(template.arguments, scope, pos)

        case ids.kw_atomic_cmpxchg
          result = this.bindAtomicCompareExchange(template.arguments, scope, pos)

        case ids.kw_rotate_left, ids.kw_rotate_right
          result = this.bindRotateLeftOrRight(name.value, template.arguments, scope, pos)

        case ids.kw_round_up, ids.kw_round_down, ids.kw_truncate
          result = this.bindRoundUpOrDown(name.value, template.arguments, scope, pos)

        case ids.kw_synchronize
          result = this.bindSynchronize(template.arguments, scope, pos)

        case ids.kw_print, ids.kw_println
          result = this.bindPrint(name.value, template.arguments, scope, pos)

        default
          isanIntrinsic = false
      }
      return (result, isanIntrinsic)
    }
    return (null, false)
  }


  fn bindAtomiSubtractOrAdd(this, keyword, template, scope, pos): ast.Node* {
    //   __atomic_subtract__( ptr: T*, adder: T )
    //        __atomic_add__( ptr: T*, adder: T )
    const arguments = this.bindCallArguments(template, scope)
    const        it = { keyword = keyword, arguments = arguments, binder = this }
    if arguments.length != 2 {
      this.cberr(pos, it) with {
        print("parameter-argument mismatch for #{it.keyword}#[%green] intrinsic\r\n\t\
          â†’ expected: 2\r\n\t\
          â†’    found: #{it.arguments.length}#[%red] ")
        it.binder.e_list_arguments(it.arguments)
      }
      return this.throwAwayList(arguments)
    }
    var pointer = arguments.items[0]
    var   adder = arguments.items[1]

    adder.value = this.make.directIfIntegral(adder.value)
     adder.type = adder.value.type

    if const ptr = pointer.type.isIndirect() {
      if ptr.pointee.isaPointerOrIntegral() {
         pointer.value = this.make.dereferenceOf(pointer.value, pointer.value.pos)
          pointer.type = pointer.value.type
        if adder.value = this.make.cast(adder.value, ptr.pointee, adder.pos, isImplicit = true) {
            adder.type = adder.value.type
        } else {
          return this.throwAwayList(arguments)
        }
        return this.make.intrinsic(keyword, arguments, ptr.pointee, pos)
      }
    }
    this.cberr(pos, it) with {
      print("invalid arguments for #{it.keyword}#[%green]\r\n\t\
        â†’ expected: Pointer to integer and integer\r\n\t\
        â†’    found: ")
      it.binder.e_list_arguments(it.arguments)
    }
    return this.throwAwayList(arguments)
  }


  fn bindAtomicDecrementOrIncrement(this, keyword, template, scope, pos): ast.Node* {
    // __atomic_decrement__( ptr: T* )
    // __atomic_increment__( ptr:T* )
    const arguments = this.bindCallArguments(template, scope)
    const        it = { keyword = keyword, arguments = arguments, binder = this }
    if arguments.length != 1 {
      this.cberr(pos, it) with {
        print("parameter-argument mismatch for #{it.keyword}#[%green] intrinsic\r\n\t\
          â†’ expected: 1\r\n\t\
          â†’    found: #{it.arguments.length}#[%red] ")
        it.binder.e_list_arguments(it.arguments)
      }
      return this.throwAwayList(arguments)
    }
    var pointer = arguments.items[0]
    if const ptr = pointer.type.isIndirect() {
      if ptr.pointee.isaPointerOrIntegral() {
        pointer.value = this.make.dereferenceOf(pointer.value, pointer.value.pos)
         pointer.type = pointer.value.type
        return this.make.intrinsic(keyword, arguments, ptr.pointee, pos)
      }
    }
    this.cberr(pos, it) with {
      print("invalid arguments for #{it.keyword}#[%green]\r\n\t\
        â†’ expected: Pointer to integer\r\n\t\
        â†’    found: ")
      it.binder.e_list_arguments(it.arguments)
    }
    return this.throwAwayList(arguments)
  }


  fn bindAtomicPause(this, template, scope, pos): ast.Node* {
    // __atomic_pause__(): Void
    const arguments = this.bindCallArguments(template, scope)
    const        it = { keyword = this.ids.kw_atomic_pause, arguments = arguments, binder = this }
    if arguments.length {
      this.cberr(pos, it) with {
        print("parameter-argument mismatch for #{it.keyword}#[%green] intrinsic\r\n\t\
          â†’ expected: 0\r\n\t\
          â†’    found: #{it.arguments.length}#[%red] ")
        it.binder.e_list_arguments(it.arguments)
      }
      return this.throwAwayList(arguments)
    }
    return this.make.intrinsic(it.keyword, arguments, ast.tyVoid, pos)
  }


  fn bindAtomicCompareExchange(this, template, scope, pos): ast.Node* {
    // __atomic_cmpxchg__( T*|T&, T, T ): Bool
    const arguments = this.bindCallArguments(template, scope)
    const        it = { keyword = this.ids.kw_atomic_cmpxchg, arguments = arguments, binder = this }
    if arguments.length != 3 {
      this.cberr(pos, it) with {
        print("parameter-argument mismatch for #{it.keyword}#[%green] intrinsic\r\n\t\
          â†’ expected: 3\r\n\t\
          â†’    found: #{it.arguments.length}#[%red] ")
        it.binder.e_list_arguments(it.arguments)
      }
      return this.throwAwayList(arguments)
    }

    const     value = arguments.items[0]
    const comparand = arguments.items[1]
    const  exchange = arguments.items[2]
    const   errors  = this.typer.errors

    if const indirect = value.type.isIndirect() {
      if indirect.pointee.isaPointerOrIntegral() {
        value.value = this.make.dereferenceOf(value.value, value.value.pos)
        value.type = value.value.type
      } else this.cberr(value.pos, it) with {
        println("'value' argument to #{it.keyword} must be a pointer to or reference of an integer\r\n\t\
          â†’ found: #{it.arguments.items[0].type}")
      }
    } else this.cberr(value.pos, it) with {
      println("'value' argument to #{it.keyword} must be a pointer or reference\r\n\t\
        â†’ found: #{it.arguments.items[0].type}")
    }

    comparand.value = this.make.directIfIntegral(comparand.value)
     comparand.type = comparand.value.type

    exchange.value = this.make.directIfIntegral(exchange.value)
     exchange.type = exchange.value.type

    if errors == this.typer.errors {
      if comparand.value = this.make.cast(comparand.value, value.type, pos, isImplicit = true) {
        comparand.type = comparand.value.type
      }
      if exchange.value = this.make.cast(exchange.value, value.type, pos, isImplicit = true) {
        exchange.type = exchange.value.type
      }
      if errors == this.typer.errors {
        return this.make.intrinsic(it.keyword, arguments, ast.tyBool, pos)
      }
    }
    return this.throwAwayList(arguments)
  }


  fn bindRotateLeftOrRight(this, keyword, template, scope, pos): ast.Node* {
    // __rotate_left__(  value: Integral, times: Integral )
    // __rotate_right__( value: Integral, times: Integral )
    const arguments = this.bindCallArguments(template, scope)
    const        it = { keyword = keyword, arguments = arguments, binder = this }
    if arguments.length != 2 {
      this.cberr(pos, it) with {
        print("parameter-argument mismatch for #{it.keyword}#[%green] intrinsic\r\n\t\
          â†’ expected: 2\r\n\t\
          â†’    found: #{it.arguments.length}#[%red] ")
        it.binder.e_list_arguments(it.arguments)
      }
      return this.throwAwayList(arguments)
    }

    const value = arguments.items[0]
    const times = arguments.items[1]

    value.value = this.make.directIfIntegral(value.value)
    value.type = value.value.type

    if value.type.isNotIntegral() {
      this.cberr(pos, it) with {
        print("invalid arguments for #{it.keyword}#[%green]\r\n\t\
          â†’ expected: Integral arguments\r\n\t\
          â†’    found: ")
        it.binder.e_list_arguments(it.arguments)
      }
      return this.throwAwayList(arguments)
    }

    if times.value = this.make.cast(times.value, value.type, times.value.pos, isImplicit = true) {
      times.type = times.value.type
      return this.make.intrinsic(keyword, arguments, value.type, pos)
    }

    return this.throwAwayList(arguments)
  }


  fn bindRoundUpOrDown(this, keyword, template, scope, pos): ast.Node* {
    // __round_up__(   value: Number )
    // __round_down__( value: Number )
    // __truncate__(   value: Number )
    const arguments = this.bindCallArguments(template, scope)
    const        it = { keyword = keyword, arguments = arguments, binder = this }
    if arguments.length != 1 {
      this.cberr(pos, it) with {
        print("parameter-argument mismatch for #{it.keyword}#[%green] intrinsic\r\n\t\
          â†’ expected: 1\r\n\t\
          â†’    found: #{it.arguments.length}#[%red] ")
        it.binder.e_list_arguments(it.arguments)
      }
      return this.throwAwayList(arguments)
    }

    const value = arguments.items[0]

    value.value = this.make.directIfNumber(value.value)
     value.type = value.value.type

    if value.type.isNotANumber() {
      this.cberr(pos, it) with {
        print("invalid arguments for #{it.keyword}#[%green]\r\n\t\
          â†’ expected: Integral arguments\r\n\t\
          â†’    found: ")
        it.binder.e_list_arguments(it.arguments)
      }
      return this.throwAwayList(arguments)
    }

    // __round_up__( value: Real )
    if value.type.isaReal() {
      return this.make.intrinsic(keyword, arguments, value.type, pos)
    }

    // __round_up__( value: Integer )
    arguments.clear()
    arguments.dispose()
    return value
  }


  fn bindSynchronize(this, template, scope, pos): ast.Node* {
    const arguments = this.bindCallArguments(template, scope)
    for argument in arguments {
      this.bindSynchronizeArgument(argument.value, scope, pos)
      argument.value = null
    }
    this.throwAwayList(arguments)
    return this.make.zero(ast.tyVoid, pos)
  }


  fn bindSynchronizeArgument(this, value, scope, pos) {
    /*  Translation ðŸ¡“
          value.srw.lock()
          defer value.srw.unlock()
    */

    const exitPos = this.make.exitPos(scope.pos)
    var      copy = this.make.copyable(value, scope)
    return if !copy

    var srw = this.findMember(this.make.copy(copy, copy.pos), this.ids.kw_srw, scope, copy.pos, copy.pos)
    if srw {
      if const lock = this.callLock(srw, scope, pos) {
        scope.appendStatement(lock)
         srw = this.findMember(copy, this.ids.kw_srw, scope, exitPos, exitPos)
        copy = null
        if srw {
          if const unlock = this.callUnlock(srw, scope, exitPos) {
            scope.deferreds.append(unlock)
          }
        }
      }
    }
    this.throwAway(copy)
  }


  fn bindPrint(this, keyword, template, scope, pos): ast.Node* {
    /*  Translation ðŸ¡“
          console.stream.lock()
          argument.format( console.stream )
          console.stream.append( "\r\n" )
          console.stream.unlock()
    */

    if !template || template.children.isEmpty() {
      this.err(pos, "no arguments for #{keyword}#[%<darkred|white>]")
    }

    // console.stream
    const stream = this.findInStd(this.ids.kw_console, this.ids.kw_stream, scope, pos)
    return null if !stream

    scope.appendStatement(this.callLock(this.make.name(stream, pos), scope, pos))

    for argument in template.children {
      if const nv = argument is src.NameValue {
        this.bindPrintArgument(nv.value, stream, scope)
      } else {
        this.bindPrintArgument(argument, stream, scope)
      }
    }

    if keyword == this.ids.kw_println {
      const value = this.make.quoted(this.ids.kw_crlf, pos)
      scope.appendStatement(this.callAppend(this.make.name(stream, pos), value, scope, pos))
    }

    return this.callUnlock(this.make.name(stream, pos), scope, pos)
  }


  fn bindPrintArgument(this, template, stream, scope):void {
    if const interpolation = template is src.Interpolation {
      for item in interpolation.children {
        switch item {
          case src.InterpolationItem {
            this.bindPrintInterpolationItem(item.value, item.fmt, stream, scope, mkPos(item))
          }
          case src.Text {
            assert item.value.length
            this.bindPrintInterpolationItem(item, Identifier*{}, stream, scope, mkPos(item))
          }
          default {
            this.bindPrintInterpolationItem(item, Identifier*{}, stream, scope, mkPos(item))
          }
        }
      }
    } else {
      this.bindPrintInterpolationItem(template, Identifier*{}, stream, scope, mkPos(template))
    }
  }


  fn bindPrintInterpolationItem(this, template, fmt, stream, scope, pos) {
    /*  Translation ðŸ¡“
          value.format( console.stream, fmt )
    */
    if const value = this.bind(template, scope) {
      if const format = this.findMember(value, this.ids.kw_format, scope, value.pos, value.pos) {
        const arguments = List(ast.Argument*){}
        arguments.append(
            this.make.argument(this.typer.emptyid, this.make.name(stream, value.pos), format.pos)
          )
        if fmt {
          const fmtValue = this.make.quoted(fmt, format.pos)
          arguments.append(this.make.argument(this.typer.emptyid, fmtValue, pos))
        }
        scope.appendStatement(this.finishCall(format, arguments, scope, pos))
      }
    }
  }


  fn getFnReturnFrom(this, instance, pos): ast.Type {
    if instance.fnreturn.isKnown() {
      return instance.fnreturn
    }
    this.cberr(pos, instance) with {
      println("unknown function return type (try specifying \
        the return type of a function in the call graph)\r\n\t\
        â†’ #{it.type}")
    }
    return ast.tyUnknown
  }


  fn bindArgument(this, template, scope) {
    if const nv = template is src.NameValue {
      if const value = this.bind(nv.value, scope) {
        return this.make.argument(nv.name, value, mkPos(template))
      }
    } else if const value = this.bind(template, scope) {
      return this.make.argument(this.typer.emptyid, value, value.pos)
    }
    return null
  }


  fn bindArrayIndex(this, template, scope): ast.Node* {
    const children = template.arguments.children
    if children.length != 1 {
      this.cberr(mkPos(template.arguments), children) with {
        println("too many array index arguments: #{it.length}")
      }
      return null
    }
    var index = this.bind(children.items[0], scope)
    var  base = this.bind(template.name, scope)
    if !base || !index {
      return this.throwAway2(base, index)
    }
    index = this.make.directIfIntegral(index)
    if base.isaTypeName() {
      return this.bindFixedArray(base, index, scope, mkPos(template))
    }
    return this.finishArrayIndex(base, index, scope, mkPos(template))
  }


  fn finishArrayIndex(this, base, index, scope, pos): ast.Node* {
     base = this.expectValue(base, scope)
    index = this.expectValue(index, scope)
    return this.throwAway2(base, index) if !base || !index

    index = this.make.directIfIntegral(index)
    if index.type.isIntegral() {
      if const ptr = base.type.isaPointer() {
        const arrayIndex = this.make.arrayIndex(base, index, ptr.pointee, pos)
        return this.make.referenceIfNotLoadable(arrayIndex)
      }
      if const ref = base.type.isaReference() {
        if ref.pointee.isanArray() || ref.pointee.isaFixedArray() {
          base = this.make.dereferenceOf(base, pos)
        }
      }
      if const array = base.type.isanArray() {
        if isIndexOutOfRange(this, base.type, index, array.children.length) {
          return this.throwAway2(base, index)
        }
        const arrayIndex = this.make.arrayIndex(base, index, array.element(), pos)
        return this.make.referenceIfNotLoadable(arrayIndex)
      }
      if const fixed = base.type.isaFixedArray() {
        if isIndexOutOfRange(this, base.type, index, fixed.length) {
          return this.throwAway2(base, index)
        }
        const arrayIndex = this.make.arrayIndex(base, index, fixed.element, pos)
        return this.make.referenceIfNotLoadable(arrayIndex)
      }
    }
    if const operator = this.findOperator(base, Tok.OpenCloseBracket, scope) {
      return this.finishOperator(operator, index, scope, pos)
    }
    this.cberr(pos, { base = base.type, index = index.type }) with {
      println("no builtin or user-define operator exits for array-index operation\r\n\t\
        â†’ #{it.base}[ #{it.index} ]")
    }
    return this.throwAway2(base, index)

    fn isIndexOutOfRange(binder, base, index, length) {
      if const constant = sema.getConstant(index) {
        const value = constant.value.i64
        if value < 0 || value >= length {
          binder.cberr(index.pos, { base = base, length = length, index = value }) with {
            println("index out of range\r\n\t\
              â†’  base: #{it.base}\r\n\t\
              â†’ index: #{it.index}#[%<red>]\r\n\t\
              â†’ range: 0 â€¦ #{it.length - 1}")
            return true
          }
        }
      }
      return false
    }
  }


  fn bindFixedArray(this, base, index, scope, pos): ast.Node* {
    index = this.make.directIfIntegral(index)

    if index.type.isIntegral() {
      index = this.make.directIfIntegral(index)
      if const constant = sema.getConstant(index) {
        const    length = constant.value.i64
        const   element = *base.type

        if length <= 0 {
          this.cberr(index.pos, length) with {
            println("invalid length value for a fixed array: #{it}")
          }
        } else {
          this.throwAway2(base, index)
          const symbol = this.make.fixedArray(element, length, scope, pos)
          return this.make.name(symbol, pos)
        }
      } else {
        this.cberr(index.pos, index) with {
          println("unexpected value of type #{nameof(it)}: #{it.type} in fixed-array length value")
        }
      }
    } else {
      this.cberr(index.pos, index) with {
        println("invalid type of fixed-array length value: #{it.type}")
      }
    }
    return this.throwAway2(base, index)
  }


  fn bindTuple(this, template, scope): ast.Node* {
    const errors = this.typer.errors
    var     list = List(ast.Node*){}
    for child in template.children {
      if const item = this.bind(child, scope) {
        list.append(item)
      }
    }
    if errors == this.typer.errors {
      const symbol = this.make.tupleFromList(list, scope, mkPos(template))
      return this.make.name(symbol, symbol.instance.pos)
    }
    return this.throwAwayList(list)
  }


  fn bindArray(this, template, scope): ast.Node* {
    const errors = this.typer.errors
    var     list = List(ast.Node*){}
    for child in template.children {
      if const item = this.bind(child, scope) {
        list.append(item)
      }
    }
    if errors != this.typer.errors {
      return this.throwAwayList(list)
    }
    var element = *list.items[0].type
    for i, child in list {
      const ub = sema.upperBound(element, child.type)
      if ub.isUnknown() {
        this.cberr(child.pos, { element = element, child = child.type }) with {
          println("array of #{it.element} cannot contain #{it.child}")
        }
      } else {
        element = ub
      }
    }
    if errors != this.typer.errors {
      return this.throwAwayList(list)
    }
    for i, child in list {
      list.items[i] = this.make.cast(child, element, child.pos, isImplicit = true)
    }
    if errors == this.typer.errors {
      const symbol = this.make.arrayFromList(list, scope, mkPos(template))
      return this.make.name(symbol, symbol.instance.pos)
    }
    return this.throwAwayList(list)
  }


  fn bindObject(this, template, scope): ast.Node* {
    const errors = this.typer.errors
    const symbol = this.make.object(scope, mkPos(template))
    const object = symbol.instance as ast.Object*
    var      bad = 0
    const   rsvd = this.enterScope(outer = scope, scope = object.scope)
    for child in template.children {
      if const nv = child.value is src.NameValue {
        if const value = this.bind(nv.value, scope) { // Bind in parent {scope}
          this.make.field(noModifiers, nv.name, value, object.scope, mkPos(nv))
        }
      } else {
        this.cberr(mkPos(child.value), child.value) with {
          println("expected name-value in object field, not #{nameof(it)}")
        }
      }
    }
    this.leaveScope(rsvd)
    if errors == this.typer.errors {
      return this.make.name(symbol, object.pos)
    }
    return null
  }


  fn bindParenthesized(this, template, scope): ast.Node* {
    if const result = this.bind(template.value, scope) {
      result.pos = mkPos(template)
      return result
    }
    return null
  }


  fn bindIfExpr(this, template, scope): ast.Node* {
    if const condition = this.bindCondition(template.condition, scope) {
      if const  iftrue = this.bind(template.iftrue, scope) {
        const   ifexpr = this.make.ifExpr(condition, iftrue, mkPos(template))
        return ifexpr if !template.ifalse
        if ifexpr.ifalse = this.bind(template.ifalse, scope) {
          const ub = sema.upperBound(iftrue.type, ifexpr.ifalse.type)
          if ub.isKnown() {
            ifexpr.iftrue = this.make.cast(ifexpr.iftrue, ub, ifexpr.iftrue.pos, isImplicit = true)
            ifexpr.ifalse = this.make.cast(ifexpr.ifalse, ub, ifexpr.ifalse.pos, isImplicit = true)
            if ifexpr.iftrue && ifexpr.ifalse {
              ifexpr.type = ub
              return ifexpr
            }
          } else {
            this.cberr(ifexpr.pos, ifexpr) with {
              println("invalid if-expr\r\n\t\
                â†’ iftrue: #{it.iftrue.type}\r\n\t\
                â†’ ifalse: #{it.ifalse.type}")
            }
          }
        }
        return this.throwAway(ifexpr)
      } else {
        this.throwAway(condition)
      }
    }
    return null
  }


  fn bindAuto(this, template, scope): ast.Node* {
    if const   value = this.bind(template.value, scope) {
      const      pos = mkPos(template)
      if const local = this.make.local(autoModifiers, this.typer.emptyid, value.type, scope, template.pos, pos) {
        scope.appendStatement(this.finishDefinition(this.make.name(local, pos), value, scope, pos))
        return this.make.name(local, value.pos)
      }
      return this.throwAway(value)
    }
    return null
  }


  fn bindBinary(this, template, scope): ast.Node* {
    const errors = this.typer.errors
    var      rhs = this.bind(template.rhs, scope)
    var      lhs = this.bind(template.lhs, scope)
    const    pos = mkPos(template)
    if !rhs || !lhs {
      return this.throwAway2(lhs, rhs)
    }
    switch const op = template.op.token {
      case Tok.Assign
        return this.finishAssignment(lhs, rhs, scope, pos)

      case Tok.TildeAssign
        return this.finishTildeAssign(lhs, rhs, scope, pos)

      case Tok.OrAssign, Tok.XOrAssign, Tok.AndAssign,
           Tok.Or,       Tok.XOr,       Tok.And
        return this.finishBitwise(lhs, op, rhs, scope, pos)

      case Tok.LeftShiftAssign, Tok.RightShiftAssign, Tok.UnsignedRightShiftAssign,
           Tok.LeftShift,       Tok.RightShift,       Tok.UnsignedRightShift
        return this.finishShift(lhs, op, rhs, scope, pos)

      case Tok.MinusAssign, Tok.PlusAssign,
           Tok.Minus,       Tok.Plus
        return this.finishAddition(lhs, op, rhs, scope, pos)

      case Tok.RemainderAssign, Tok.DivideAssign, Tok.MultiplyAssign,
           Tok.Remainder,       Tok.Divide,       Tok.Multiply
        return this.finishMultiplicative(lhs, op, rhs, scope, pos)

      case Tok.OrOr, Tok.AndAnd, Tok.Equal, Tok.NotEqual, Tok.Less, Tok.LessOrEqual, Tok.Greater,
           Tok.GreaterOrEqual
        return this.finishCondition(lhs, op, rhs, scope, pos)

      case Tok.To
        return this.finishTo(lhs, rhs, scope, pos)

      case Tok.As
        return this.finishAs(lhs, rhs, scope, pos)

      case Tok.Is, Tok.IsNot
        return this.finishIs(lhs, op, rhs, scope, pos)
    }
    if this.typer.errors == errors {
      this.cberr(pos, { lhs = lhs.type, op = template.op.token, rhs = rhs.type }, fn(ctx) =
        println("invalid binary operation #{ctx.op.value()}#[%<red|white>]\r\n\t\
          â†’ #{ctx.lhs} #{ctx.op.value()} #{ctx.rhs}"))
    }
    return this.throwAway2(lhs, rhs)
  }


  fn checkAssignability(this, lhs, scope, ignoreConst = false) {
    if !lhs.isAssignable(scope, ignoreConst) {
      auto str = String{}
      buildName(str, lhs, modifiers = true, dot = false)
      this.cberr(lhs.pos, { lhs = lhs, name = str }) with {
        println("lhs is not assignable\r\n\t\
          â†’ #{it.name}: #{it.lhs.type}\r\n\t\
          â†’ #{nameof(it.lhs)}")
      }
    }

    fn buildName(str, node, modifiers, dot):void {
      switch node {
        case ast.Name {
          if modifiers {
            putModifiers(str, node.symbol)
          } else if dot {
            str.append(".")
          }
          str.append(node.symbol.name)
        }
        case ast.MemberName {
          const length = str.length
          if modifiers {
            putModifiers(str, node.symbol)
          }
          buildName(str, node.base, modifiers = false, dot = length)
          str.append(".").append(node.symbol.name)
        }
        default str.append('.')
      }

      fn putModifiers(str, symbol) {
        const modifiers = symbol.modifiers()
        if modifiers.isConst {
          str.append(" ") if str.length
          str.append("const ")
        }
        if modifiers.isReadOnly {
          str.append(" ") if str.length && !modifiers.isConst
          str.append("readonly ")
        }
      }
    }
  }


  fn bindUnaryPrefix(this, template, scope): ast.Node* {
    const errors = this.typer.errors
    const    pos = mkPos(template)
    const     op = template.op.token

    if op == Tok.New {
      return this.bindNew(template, scope)
    }

    var rhs = this.bind(template.rhs, scope)
    return null if !rhs

    switch op {
      case Tok.Delete
        return this.bindDelete(rhs, template.withPart, scope, pos)

      case Tok.NameOf
        return this.bindNameOf(rhs, scope, pos)

      case Tok.Star
        return this.bindStarOperator(rhs, scope, pos)

      case Tok.Ampersand
        return this.bindAmpersandOperator(rhs, scope, pos)

      case Tok.StarAmpersand
        return this.bindStarAmpersandOperator(rhs, scope, pos)

      case Tok.AmpersandStar
        return this.bindAmpersandStarOperator(rhs, scope, pos)

      case Tok.LogicalIs
        return this.finishLogicalIs(rhs, scope, pos)

      case Tok.LogicalNot
        return this.finishLogicalNot(rhs, scope, pos)

      case Tok.SizeOf
        return this.make.sizeOf(rhs, pos)

      case Tok.TypeOf
        return this.bindTypeOf(rhs, pos)

      case Tok.Plus {
        rhs = this.make.directIfNumeric(rhs)
        if rhs.type.isNumeric() {
          rhs.pos = pos
          return rhs
        }
      }

      case Tok.Minus
        return this.bindNegate(rhs, scope, pos)

      case Tok.Tilde
        return this.bindBitwiseNot(rhs, scope, pos)

      case Tok.MinusMinus
        return this.bindPreDecrement(rhs, scope, pos)

      case Tok.PlusPlus
        return this.bindPreIncrement(rhs, scope, pos)
    }
    if errors == this.typer.errors {
      this.cberr(pos, { op = template.op.token, rhs = rhs.type }) with {
        println("invalid unary prefix operation #{it.op.value()}#[%<red|white>]\r\n\t\
          â†’ #{it.op.value()} #{it.rhs}")
      }
    }
    return this.throwAway(rhs)
  }


  fn bindNew(this, template, scope): ast.Node* {
    const pos = mkPos(template)
    if const initializer = template.rhs is src.Initializer {
      if const name = this.bind(initializer.name, scope) {
        const arguments = this.bindInitializerArguments(initializer.arguments, scope)
        if arguments.isEmpty() && this.hasChildren(initializer.arguments) {
          return this.throwAway(name)
        }
        return this.finishNew(name, arguments, scope, mkPos(initializer.arguments), pos)
      }
    }
    if const name = this.bind(template.rhs, scope) {
      return this.finishNew(name, List(ast.InitializerArgument*){}, scope, pos, pos)
    }
    return null
  }


  fn bindDelete(this, rhs, withPartTemplate, scope, pos): ast.Node* {
    var    value = this.expectValue(rhs, scope)
    var withPart = this.bind(withPartTemplate, scope)

    if !value || (withPartTemplate && !withPart) {
      return this.throwAway2(value, withPart)
    }

    return this.finishDelete(value, withPart, scope, pos)
  }


  fn bindNameOf(this, value, scope, pos): ast.Node* {
    //  Translation ðŸ¡“
    //    T.__nameof__( value )
    value = this.expectValue(value, scope)
    return null if !value

    value = this.make.dereferenceOf(value, value.pos)
    return null if !value

    if const callee = this.findMember(value, this.ids.kw_nameof, scope, value.pos, pos) {
      const arguments = List(ast.Argument*){}
      if const call = this.finishCall(callee, arguments, scope, pos) {
        return call if call.type.isaSymbol() == this.sym_string
        this.cberr(call.pos, { expected = this.sym_string.type(), found = call.type }) with {
          println("unexpected value of #{'nameof'}#[%<darkred|white>]\r\n\t\
            â†’ expected: #{it.expected}\r\n\t\
            â†’    found: #{it.found}")
        }
        return this.throwAway(call)
      }
    }
    return null
  }


  fn bindStarOperator(this, value, scope, pos): ast.Node* {
    //  Syntax: *value: T
    // Require: Â· {value} is not a typename
    //          Â· T is not Void
    value = this.expectValue(value, scope)
    return null if !value

    return this.make.dereferenceOf(value, pos)
  }


  fn bindAmpersandOperator(this, rhs, scope, pos): ast.Node* {
    //  Syntax: &value: T
    // Require: Â· {value} is not a typename
    //          Â· T is not Void
    //          Â· {value} is addressable
    var value = this.expectValue(rhs, scope)
    return null if !value

    return this.make.addressOf(value, pos)
  }


  fn bindStarAmpersandOperator(this, rhs, scope, pos): ast.Node* {
    //  Syntax: *& value: T
    // Require: Â· {value} is not a typename
    //          Â· T is not Void
    //          Â· {value} is addressable
    var value = this.expectValue(rhs, scope)
    return null if !value

    // Conversion table:
    //    T       âŸ¶ T&
    //    T&      âŸ¶ T&
    //    T*      âŸ¶ T&
    //    T**     âŸ¶ T&
    //    T***... âŸ¶ fail
    return this.make.starAmpersandOf(value, pos)
  }


  fn bindAmpersandStarOperator(this, rhs, scope, pos): ast.Node* {
    //  Syntax: &* value: T
    // Require: Â· {value} is not a typename
    //          Â· T is not Void
    //          Â· {value} is addressable
    var value = this.expectValue(rhs, scope)
    return null if !value

    // Conversion table:
    //    T       âŸ¶ T&
    //    T&      âŸ¶ T&
    //    T*      âŸ¶ T&
    //    T**     âŸ¶ T*
    //    T***... âŸ¶ fail
    return this.make.ampersandStarOf(value, pos)
  }


  fn bindTypeOf(this, rhs, pos): ast.Node* {
    const value = this.make.typeOf(rhs.type, pos)
    this.throwAway(rhs)
    return value
  }


  fn bindNegate(this, rhs, scope, pos): ast.Node* {
    var value = this.expectValue(rhs, scope)
    return null if !value

    if value.type.isaPointer() {
      this.cberr(pos, value) with {
        println("unary-prefix '-' operator cannot be applied to a pointer")
      }
      return this.throwAway(value)
    }

    value = this.make.directIfNumber(value)
    if value.type.isaNumber() {
      return this.make.negate(value, pos)
    }

    if const operator = this.findOperator(value, Tok.Minus, scope) {
      return this.finishOperator(operator, ast.Node*{}, scope, pos)
    }

    this.cberr(value.pos, value) with {
      println("no unary-prefix '-' operator exists to make the operation possible\r\n\t\
        â†’ - #{it.type}")
    }
    return this.throwAway(value)
  }


  fn bindBitwiseNot(this, rhs, scope, pos): ast.Node* {
    var value = this.expectValue(rhs, scope)
    return null if !value

    if value.type.isaPointer() {
      this.cberr(pos, value) with {
        println("unary-prefix '~' operator cannot be applied to a pointer")
      }
      return this.throwAway(value)
    }

    value = this.make.directIfIntegral(value)
    if value.type.isIntegral() {
      return this.make.bitwiseNot(value, pos)
    }

    if const operator = this.findOperator(value, Tok.Tilde, scope) {
      return this.finishOperator(operator, ast.Node*{}, scope, pos)
    }

    this.cberr(value.pos, value) with {
      println("no unary-prefix '~' operator exists to make the operation possible\r\n\t\
        â†’ - #{it.type}")
    }
    return this.throwAway(value)
  }


  fn bindPreDecrement(this, rhs, scope, pos): ast.Node* {
    var value = this.expectValue(rhs, scope)
    return null if !value

    if value.type.isaPointer() {
      this.checkAssignability(value, scope)
      return this.make.preDecrement(value, pos)
    }

    value = this.make.directIfNumber(value)
    if value.type.isaNumber() {
      this.checkAssignability(value, scope)
      return this.make.preDecrement(value, pos)
    }

    if const operator = this.findOperator(value, Tok.MinusMinus, scope) {
      return this.finishOperator(operator, ast.Node*{}, scope, pos)
    }

    this.cberr(value.pos, value) with {
      println("no unary-prefix '--' operator exists to make the operation possible\r\n\t\
        â†’ -- #{it.type}")
    }
    return this.throwAway(value)
  }


  fn bindPreIncrement(this, rhs, scope, pos): ast.Node* {
    var value = this.expectValue(rhs, scope)
    return null if !value

    if value.type.isaPointer() {
      this.checkAssignability(value, scope)
      return this.make.preIncrement(value, pos)
    }

    value = this.make.directIfNumber(value)
    if value.type.isaNumber() {
      this.checkAssignability(value, scope)
      return this.make.preIncrement(value, pos)
    }

    if const operator = this.findOperator(value, Tok.PlusPlus, scope) {
      return this.finishOperator(operator, ast.Node*{}, scope, pos)
    }

    this.cberr(value.pos, value) with {
      println("no unary-prefix '++' operator exists to make the operation possible\r\n\t\
        â†’ ++ #{it.type}")
    }
    return this.throwAway(value)
  }

  //-------------------------------------------------------------------------------------------------------
  fn bindUnarySuffix(this, template, scope): ast.Node* {
    const pos = mkPos(template)
    var   lhs = this.bind(template.lhs, scope)
    return null if !lhs

    switch const op = template.op.token {
      case Tok.Star // T*
        return this.bindPointerTypeOf(lhs, pos)

      case Tok.Ampersand // T&
        return this.bindReferenceTypeOf(lhs, pos)

      case Tok.MinusMinus
        return this.bindPostDecrement(lhs, scope, pos)

      case Tok.PlusPlus
        return this.bindPostIncrement(lhs, scope, pos)

      default
        this.cberr(pos, { lhs = lhs.type, op = template.op.token }) with {
          println("invalid unary prefix operation #{it.op.value()}#[%<red|white>]\r\n\t\
            â†’ #{it.lhs} #{it.op.value()}")
        }
    }
    return this.throwAway(lhs)
  }


  fn bindReferenceTypeOf(this, value, pos): ast.Node* {
    // Conversion table:
    //    T   âŸ¶ T&
    //    T&  âŸ¶ T&&  âŸ¶ T&
    //    T*  âŸ¶ T*&  âŸ¶ T&
    //    T** âŸ¶ T**& âŸ¶ T***
    value = this.expectType(value)
    return null if !value

    return value if value.type.isaReference()

    if const ptr = value.type.isaPointer() {
      // T*& is the address of a reference.
      // Make it decay to T&.
      const pointee = ptr.pointee
      if pointee.isIndirect() {
        const type = this.typer.types.pointerOf(value.type)
        if type.isKnown() {
          return this.make.typeOfOrModify(value, type, pos)
        }
      } else {
        const type = this.typer.types.referenceOf(pointee)
        if type.isKnown() {
          return this.make.typeOfOrModify(value, type, pos)
        }
      }
    } else { // T&
      const type = this.typer.types.referenceOf(value.type)
      if type.isKnown() {
        return this.make.typeOfOrModify(value, type, pos)
      }
    }
    this.cberr(pos, value) with {
      println("cannot create the pointer type of #{it.type}")
    }
    return this.throwAway(value)
  }


  fn bindPointerTypeOf(this, value, pos): ast.Node* {
    // Conversion table:
    //    T  âŸ¶ T*
    //    T& âŸ¶ T&* âŸ¶ T*
    //    T* âŸ¶ T**
    value = this.expectType(value)
    return null if !value

    return value if value.type.isaReference()

    if const ref = value.type.isaReference() {
      const pointee = ref.pointee
      const type = this.typer.types.pointerOf(pointee)
      if type.isKnown() {
        return this.make.typeOfOrModify(value, type, pos)
      }
    } else { // T*
      const type = this.typer.types.pointerOf(value.type)
      if type.isKnown() {
        return this.make.typeOfOrModify(value, type, pos)
      }
    }
    this.cberr(pos, value) with {
      println("cannot create the reference type of #{it.type}")
    }
    return this.throwAway(value)
  }


  fn bindPostDecrement(this, rhs, scope, pos): ast.Node* {
    var value = this.expectValue(rhs, scope)
    return null if !value

    if value.type.isaPointer() {
      this.checkAssignability(value, scope)
      return this.make.postDecrement(value, pos)
    }

    value = this.make.directIfNumeric(value)
    if value.type.isNumeric() {
      this.checkAssignability(value, scope)
      return this.make.postDecrement(value, pos)
    }

    if const operator = this.findOperator(value, Tok.MinusMinus, scope) {
      return this.finishOperator(operator, ast.Node*{}, scope, pos)
    }

    this.cberr(value.pos, value) with {
      println("no unary-suffix '--' operator exists to make the operation possible\r\n\t\
        â†’ #{it.type} --")
    }
    return this.throwAway(value)
  }


  fn bindPostIncrement(this, rhs, scope, pos): ast.Node* {
    var value = this.expectValue(rhs, scope)
    return null if !value

    if value.type.isaPointer() {
      this.checkAssignability(value, scope)
      return this.make.postIncrement(value, pos)
    }

    value = this.make.directIfNumeric(value)
    if value.type.isNumeric() {
      this.checkAssignability(value, scope)
      return this.make.postIncrement(value, pos)
    }

    if const operator = this.findOperator(value, Tok.PlusPlus, scope) {
      return this.finishOperator(operator, ast.Node*{}, scope, pos)
    }

    this.cberr(value.pos, value) with {
      println("no unary-suffix '++' operator exists to make the operation possible\r\n\t\
        â†’ #{it.type} ++")
    }
    return this.throwAway(value)
  }

  //-------------------------------------------------------------------------------------------------------
  fn bindMemberName(this, template, scope): ast.Node* {
    if const lhs = this.bind(template.lhs, scope) {
      const rhs = template.rhs
      switch rhs {
        case src.Name
          return this.findMember(lhs, rhs.value, scope, mkPos(rhs), mkPos(template))
      }
      this.cberr(mkPos(rhs), rhs) with {
        println("cannot resolve rhs of '.' because it is a #{nameof(it)}")
      }
      return this.throwAway(lhs)
    }
    return null
  }


  fn bindNameValueStmt(this, template, scope): ast.Node* {
    const errors = this.typer.errors
    if template.keyword == Tok.Define {
      if const value = this.evaluate(template.value, scope) {
        const def = this.make.define_(template.name, value, mkPos(template))
        const (symbol, duplicate) = scope.appendSymbol(template.name, this.typer.nullTemplate, def)
        if duplicate {
          this.e_exists(def.pos, template.name, template)
          return null
        }
        return this.make.name(symbol, def.pos)
      }
    }
    if errors == this.typer.errors {
      this.cberr(mkPos(template), template) with {
        println("invalid #{nameof(it.keyword)}#[%<darkred|white>] in Stmt context")
      }
    }
    return null
  }


  fn bindName(this, template, scope): ast.Node* {
    const pos = mkPos(template)
    switch template.value {
      case this.ids.kw_file {
        if const name = scope.parentFileName() {
          return this.make.quoted(name, pos)
        } else {
          this.e_not_found(pos, scope.owner.type, template.value)
          return null
        }
      }
      case this.ids.kw_line {
        return this.make.int(pos.range.start.line, pos)
      }
      case this.ids.kw_function {
        if const function = this.currentFunction(scope) {
          return this.make.quoted(function.dotName, pos)
        } else {
          this.e_not_found(pos, scope.owner.type, template.value)
          return null
        }
      }
    }
    if const found = this.find(scope, template.value, pos) {
      if const symbol = this.tryInstantiate(found, scope, pos) {
        if this.site.isStatic {
          return this.make.extract(symbol, pos)
        }
        return this.make.name(symbol, pos)
      }
    }
    return null
  }


  fn bindInterpolation(this, template, scope): ast.Node* {
    // TODO:
    return this.make.constant(Immediate{}, this.sym_String.instance.type, mkPos(template))
  }


  fn bindQuoted(this, template, scope): ast.Quoted* {
    if template.isWChar {
      return this.finishQuotedUtf16(template.value, scope, mkPos(template))
    }
    return this.finishQuoted(template.value, scope, mkPos(template))
  }


  fn finishQuoted(this, value, scope, pos): ast.Quoted* {
    return this.make.quoted(value, pos)
  }


  fn finishQuotedUtf16(this, value, scope, pos) {
    const symbol = this.findInStd(this.ids.kw_strings, this.ids.kw_wstring, scope, pos)
    return null if !symbol
    var   wtext = WChar*{}
    var wlength = 0
    if value.length {
      import malloc, mfree from std.memory
      wlength = os.MultiByteToWideChar(
          CodePage       = os.CP_UTF8,
          dwFlags        = 0,
          lpMultiByteStr = value.text,
          cbMultiByte    = value.length,
          lpWideCharStr  = wtext,
          cchWideChar    = 0
        )
      if wlength == 0 {
        this.cberr(pos, { value = value, error = os.GetLastError() }) with {
          println("os.MultiByteToWideChar failed to allocate memory for converting Utf8 to Utf16\r\n\t\
            â†’ value: #{it.value}\r\n\t   \
              error: #{it.error}#[%0x]")
        }
        return null
      }

      wtext = malloc(WChar*{}, sizeof(WChar) * wlength + sizeof(WChar))
      const result = os.MultiByteToWideChar(
          CodePage       = os.CP_UTF8,
          dwFlags        = 0,
          lpMultiByteStr = value.text,
          cbMultiByte    = value.length,
          lpWideCharStr  = wtext,
          cchWideChar    = wlength
        )
      if result == 0 {
        this.cberr(pos, { value = value, error = os.GetLastError() }) with {
          println("os.MultiByteToWideChar failed to convert Utf8 to Utf16\r\n\t\
            â†’ value: #{it.value}\r\n\t   \
              error: #{it.error}#[%0x]")
        }
        mfree(wtext)
        return null
      }
    }
    const utf16 = this.ids.getUtf16(wtext, wlength)
    return this.make.quotedUtf16(utf16, symbol.type(), pos)
  }


  fn bindCharacter(this, template, scope) {
    const immediate = Immediate{ char = template.value }
    return this.make.constant(immediate, ast.tyChar, mkPos(template))
  }


  fn bindConstant(this, template, scope) {
    const       pos = mkPos(template)
    const immediate = Immediate{ u64 = template.value.u64 }
    if template.kind == template.Kind.Null {
      return this.make.constant(immediate, this.typer.types.pointerOf(ast.tyVoid), pos)
    }
    const kind = (Int32(ast.Kind.Void) + Int32(template.kind) - Int32(template.Kind.Void)) as ast.Kind
    return this.make.constant(immediate, ast.Type{ kind = kind }, pos)
  }

  //-------------------------------------------------------------------------------------------------------
  fn find(this, scope, name, pos): ast.Symbol* {
    if name == this.ids.kw_super {
      return this.findSuper(scope, pos)
    }

    const  type = ownerType(scope)
    const found = scope.find(name)
    if found {
      if this.site.isStatic && found.cannotBeAccessedStatically() {
        this.cberr(pos, found) with {
          println("cannot access #{it.name} in a static context")
        }
        return null
      }
      return found
    }
    this.e_not_found(pos, type, name)
    return null

    fn ownerType(scope): ast.Type& {
      const owner = scope.owner
      switch owner {
        case ast.Folder   return owner.type
        case ast.File     return owner.type
        case ast.Struct   return owner.type
        case ast.Union    return owner.type
        case ast.Enum     return owner.type
        case ast.Function return owner.type
        default           return ownerType(scope.parent)
      }
      return ast.tyUnknown
    }
  }


  fn findSuper(this, scope, pos): ast.Symbol* {
    if const function = this.currentFunction(scope) {
      if const st = function.scope.parent.owner is ast.Struct {
        if const found = st.scope.findLocal(this.ids.kw_super) {
          if const symbol = this.tryInstantiate(found, scope, pos) {
            if this.site.isStatic && symbol.cannotBeAccessedStatically() {
              this.cberr(pos, found) with {
                println("cannot access #{it.name} in a static context")
              }
              return null
            }
          }
          return null
        }
        this.e_not_found(pos, st.type, this.ids.kw_super)
        return null
      }
    }
    this.cberr(pos, null) with {
      println("the keyword #{'super'}#[<darkgreen|white>] can only be used inside a member function")
    }
    return null
  }


  fn findSymbol(this, type, name, scope, pos): ast.Symbol* {
    if const lookupScope = type.getLookupScope() {
      if const found = lookupScope.findMember(name) {
        if const symbol = this.tryInstantiate(found, scope, pos) {
          if this.site.isStatic && symbol.cannotBeAccessedStatically() {
            this.cberr(pos, found) with {
              println("cannot access #{it.name} in a static context")
            }
          }
          return symbol
        }
      }
    }
    return null
  }


  fn findOperator(this, base, op, scope): ast.Node* {
    return null if base.type.isaPointer()

    const name = this.ids.get(op.value())
    if name.isEmpty() {
      this.cbinfo(base.pos, base) with {
        println("empty operator name with base type #{it.type}")
      }
      return null
    }

    var baseType = *base.type
    if const ptr = baseType.isIndirect() {
      baseType = ptr.pointee
    }

    if const symbol = this.findSymbol(baseType, name, scope, base.pos) {
      if symbol.isaFunction() {
        if base = this.make.dereferenceOf(base, base.pos) {
          return this.make.member(base, symbol, base.pos)
        }
        // Must return something because we've consumed {base} and the caller expects {base} to be
        // the same if this function fails. So pretend that we succeeded and just pass void along.
        return this.make.zero(ast.tyVoid, this.site.pos)
      }
    }

    return null
  }


  fn findMember(this, baseval, name, scope, namePos, posval): ast.Node* {
    const pos = *posval
    var  base = baseval as ast.Node*

    if const ptr = base.type.isIndirect() {
      if ptr.pointee.isIndirect() || ptr.pointee.isVoid() {
        this.e_not_found(namePos, base.type, name)
        return this.throwAway(base)
      }
      base = this.make.dereferenceOf(base, pos)
      return null if !base
    }

    if const found = this.findSymbol(base.type, name, scope, pos) {
      return this.finishFindMember(base, found, scope, namePos, pos)
    }

    if name == this.ids.kw_length {
      if const array = base.type.isanArray() {
        this.throwAway(base)
        return this.make.int(array.children.length, pos)
      } if const fixed = base.type.isaFixedArray() {
        this.throwAway(base)
        return this.make.int(fixed.length, pos)
      } if const ch = base.type.isChar() {
        this.throwAway(base)
        return this.make.int(1, pos)
      }
    } else if name == this.ids.kw_text || name == this.ids.kw_items {
      if const array = base.type.isanArray() { // &base[0]
        if base = this.expectValue(base, scope) {
          const index = this.make.int(0, pos)
          const value = this.make.arrayIndex(base, index, array.element(), pos)
          return this.make.addressOf(value, pos)
        }
        return null
      }
      if const fixed = base.type.isaFixedArray() { // &base[0]
        if base = this.expectValue(base, scope) {
          const index = this.make.int(0, pos)
          const value = this.make.arrayIndex(base, index, fixed.element, pos)
          return this.make.addressOf(value, pos)
        }
        return null
      }
      if const ch = base.type.isChar() {
        if base = this.expectValue(base, scope) {
          return this.make.addressOf(base, pos)
        }
        return null
      }
      if name == this.ids.kw_items {
        if const sym = base.type.isaSymbol() {
          if sym == this.sym_string || sym == this.sym_String {
            return this.findMember(base, this.ids.kw_text, scope, namePos, pos)
          }
        }
      }
    } else if name == this.ids.kw_format {
      switch base.type.isaBuiltin() {
        case ast.Kind.Void   return this.findFormatterFunction(base, this.ids.kw_formatVoid,   scope, namePos, pos)
        case ast.Kind.Bool   return this.findFormatterFunction(base, this.ids.kw_formatBool,   scope, namePos, pos)
        case ast.Kind.WChar  return this.findFormatterFunction(base, this.ids.kw_formatWChar,  scope, namePos, pos)
        case ast.Kind.UInt8  return this.findFormatterFunction(base, this.ids.kw_formatUInt8,  scope, namePos, pos)
        case ast.Kind.UInt16 return this.findFormatterFunction(base, this.ids.kw_formatUInt16, scope, namePos, pos)
        case ast.Kind.UInt32 return this.findFormatterFunction(base, this.ids.kw_formatUInt32, scope, namePos, pos)
        case ast.Kind.UInt64 return this.findFormatterFunction(base, this.ids.kw_formatUInt64, scope, namePos, pos)
        case ast.Kind.Char   return this.findFormatterFunction(base, this.ids.kw_formatChar,   scope, namePos, pos)
        case ast.Kind.Int8   return this.findFormatterFunction(base, this.ids.kw_formatInt8,   scope, namePos, pos)
        case ast.Kind.Int16  return this.findFormatterFunction(base, this.ids.kw_formatInt16,  scope, namePos, pos)
        case ast.Kind.Int32  return this.findFormatterFunction(base, this.ids.kw_formatInt32,  scope, namePos, pos)
        case ast.Kind.Int64  return this.findFormatterFunction(base, this.ids.kw_formatInt64,  scope, namePos, pos)
        case ast.Kind.Float  return this.findFormatterFunction(base, this.ids.kw_formatFloat,  scope, namePos, pos)
        case ast.Kind.Double return this.findFormatterFunction(base, this.ids.kw_formatDouble, scope, namePos, pos)
      }
    }
    this.e_not_found(namePos, base.type, name)
    return this.throwAway(base)
  }


  fn findFormatterFunction(this, base, name, scope, namePos, pos) {
    if const structFound = this.findInStd(this.ids.kw_formatter, this.ids.kw_builtins, scope, namePos) {
      if const functionFound = this.findSymbol(structFound.type(), name, scope, namePos) {
        return this.finishFindMember(base, functionFound, scope, namePos, pos)
      }
    }
    this.e_not_found(namePos, base.type, name)
    return this.throwAway(base)
  }


  fn finishFindMember(this, base, found, scope, namePos, posval): ast.Node* {
    const pos = *posval
    if found.canBeAccessedStatically() {
      if found.type().isaFunctionSymbol() && base.isNotATypeName() {
        return this.make.member(base, found, pos)
      }
      this.throwAway(base)
      return this.make.name(found, pos)
    }
    if this.site.isStatic {
      this.cberr(namePos, found.name) with {
        println("cannot access #{it}#[%<red>] in a static context")
      }
      return this.throwAway(base)
    }
    const member = this.make.member(base, found, pos)
    if found.instance is ast.Field {
      return this.make.referenceIfNotLoadable(member)
    }
    return member
  }

  fn findInStd(this, fileName, name, scope, pos): ast.Symbol* {
    const isstring = fileName == this.ids.kw_strings && name == this.ids.kw_string
    return this.sym_string if isstring && this.sym_string

    const isString = fileName == this.ids.kw_strings && name == this.ids.kw_String
    return this.sym_String if isString && this.sym_String

    if !this.std {
      const  root = (this.typer.main.instance as ast.File*).scope.parent.owner as ast.Folder*
      const found = root.scope.find(this.ids.kw_std)
      if !found || !found.instance || found.instance !is ast.Folder {
        this.e_not_found(pos, ast.tyUnknown, name)
        return null
      }
      this.std = this.tryInstantiate(found, scope, pos).instance as ast.Folder*
    }

    var found = this.std.scope.findLocal(fileName, asDotOperator = true)
    if !found {
      this.e_not_found(pos, this.std.type, fileName)
      return null
    }

    found = this.tryInstantiate(found, scope, pos)
    if !found || !found.instance {
      this.e_not_found(pos, this.std.type, name)
      return null
    }

    if const symbol = this.findSymbol(found.type(), name, scope, pos) {
      if isstring {
        if symbol.instance {
          this.sym_string = symbol
        } else this.cberr(pos, symbol) with {
          println("known type #{it.type()} not instantiated")
        }
      } else if isString {
        if symbol.instance {
          this.sym_String = symbol
        } else this.cberr(pos, symbol) with {
          println("known type #{it.type()} not instantiated")
        }
      }
      return symbol
    }
    this.e_not_found(pos, found.type(), name)
    return null
  }

  //--------------------------------------------------------------------------------------------------------
  fn tryInstantiate(this, symbol, scope, pos): ast.Symbol* {
    if symbol.instance {
      switch symbol.instance {
        case ast.Folder return this.visitFolder(symbol, scope, pos)
        case ast.File   return this.visitFile(symbol, scope, pos)
        case ast.Import return this.visitImport(symbol, scope, pos)
      }
      return symbol
    }
    assert symbol.template
    switch symbol.template {
      case s: src.Struct {
        if doesNotHaveChildren(s.parameters)
          return this.instantiateParameterLess(symbol, scope, pos)
      }
      case u: src.Union {
        if doesNotHaveChildren(u.parameters)
          return this.instantiateParameterLess(symbol, scope, pos)
      }
      case e: src.Enum {
        return this.instantiateParameterLess(symbol, scope, pos)
      }
      case f: src.Function {
        if doesNotHaveChildren(f.parameters)
          return this.instantiateParameterLess(symbol, scope, pos)
      }
    }
    return symbol
  }


  fn instantiateParameterLess(this, symbol, scope, pos): ast.Symbol* {
    auto site = this.makeCallSite(scope, pos)
    this.site = &site
    const type = instantiator.instantiateParameterLess(site, symbol)
    return type.isaSymbol()
  }


  //-------------------------------------------------------------------------------------------------------
  fn zero(this, type, scope, pos): ast.Node* {
    const arguments = List(ast.InitializerArgument*){}
    return this.finishInitializer(type, arguments, scope, pos, pos)
  }

  fn finishInitializer(this, type, arguments, scope, argumentsPos, pos): ast.Node* {
    if type.isaBuiltin() || type.isIndirect() || type.isanEnum() {
      if arguments.isEmpty() {
        if const en = type.isanEnum() {
          // Let E{} evaluate to E.firstEntry or a zero constant if E.scope is empty.
          if const first = en.firstEntry() {
            return this.make.name(first, pos)
          }
        }
        return this.make.zero(type, pos)
      }

      // Disallow multiple initializer arguments to T*, T&, B or E.
      if arguments.length != 1 {
        this.cberr(argumentsPos, { type = type, arguments = arguments.length }) with {
          println("expected 1 argument to initializer of #{it.type}\r\n\t\
            â†’ found: #{it.arguments}")
        }
        return this.throwAwayList(arguments)
      }

      // Cast the 1 and only argument to T*, T&, B or E.
      const argument = arguments.items[0]
      if argument.value = this.make.cast(argument.value, type, pos, isImplicit = false) {
        const    result = argument.value
         argument.value = null
        this.throwAwayList(arguments)
        return result
      }
      return this.throwAwayList(arguments)
    }

    var symbol = type.isaSymbol()
    if !symbol {
      this.cberr(pos, type) with {
        println("#{it} cannot be initialized. wtf1?")
      } 
      return this.throwAwayList(arguments)
    }

    symbol = this.tryInstantiate(symbol, scope, pos)
    return this.throwAwayList(arguments) if !symbol
    if !symbol.instance {
      if symbol.template is src.Function {
        return this.finishFunctionInitializer(symbol, arguments, scope, pos)
      } else this.cberr(pos, symbol.type()) with {
        println("expected function template for initialization\r\n\t\
          â†’ found: #{it}")
      }
      return this.throwAwayList(arguments)
    }

    switch symbol.instance {
      case ast.Struct
        return this.finishStructInitializer(symbol, arguments, scope, pos)
      case ast.Union
        return this.finishUnionInitializer(symbol, arguments, scope, argumentsPos, pos)
      case ast.Function
        return this.finishFunctionInitializer(symbol, arguments, scope, pos)
      case ast.Array
        return this.finishArrayInitializer(symbol, arguments, scope, pos)
      case ast.Object
        return this.finishObjectInitializer(symbol, arguments, scope, pos)  
      case ast.FixedArray
        return this.finishFixedArrayInitializer(symbol, arguments, scope, pos)  
    }
    this.cberr(pos, type) with {
      println("#{it} is not initializable. wtf2?")
    }
    return this.throwAwayList(arguments)
  }


  fn finishStructInitializer(this, symbol, arguments, scope, pos): ast.Node* {
    const errors = this.typer.errors
    const     st = symbol.instance as ast.Struct*

    // For each {argument} in {arguments} find a {field} in {st} to initialize {field} with.
    auto path = List(ast.Symbol*){}
    for argument in arguments {
      const    errors_ = this.typer.errors
      if const   found = this.findPathToStructFieldForInitializerArgument(st, path, argument) {
        const    field = found.instance as ast.Field*
        argument.field = found
         argument.path = path
        argument.value = this.make.cast(argument.value, field.type, argument.value.pos, isImplicit = false)
         argument.type = field.type
        path = List(ast.Symbol*){}
        if field.name == this.ids.kw_typeid {
          this.cberr(argument.pos, argument) with {
            println("#{it.name}#[%<darkred|white>] is initialized by the compiler")
          }
        }
      } else {
        if errors_ == this.typer.errors {
          this.e_not_found(argument.pos, st.type, argument.name)
        }
        path.clear()
      }
    }

    return this.throwAwayList(arguments) if errors != this.typer.errors

    // Now initialize all fields of {st} that have not been initialized by an {argument} in {arguments}.
    st.forEachField(path, { make = this.make, arguments = arguments, pos = pos }) with path, it, field {
      const fieldIsAlreadyInitialized = it.arguments.contains(field) with field, argument {
        return field.name == argument.name
      }
      return if fieldIsAlreadyInitialized
      const argument = it.make.initializerArgumentWithField(field, it.pos)
      argument.field = field
      it.arguments.append(argument)
      for symbol in path {
        argument.path.append(symbol)
      }
    }
    return this.make.initializer(arguments, symbol.instance.type, pos)
  }


  fn findPathToStructFieldForInitializerArgument(this, st, path, argument): ast.Symbol* {
    const idx = st.scope.symbols.indexOf(argument.name.hash)
    if idx >= 0 {
      const    found = st.scope.symbols.items[idx].value
      if const field = found.instance is ast.Field {
        return found if !field.isSuper
      }
      this.cberr(argument.pos, { argument = argument.name, type = st.type }) with {
        println("#{it.argument}#[%<darkred|white>] does not initialize a member field of #{it.type}")
      }
      return null
    }
    for nv in st.scope.symbols {
      const symbol = nv.value
      if const field = symbol.instance is ast.Field {
        if field.isSuper {
          path.append(symbol)
          if const found = this.findPathToStructFieldForInitializerArgument(field.type.isaStruct(), path, argument) {
            return found
          }
          path.removeLast()
        } else {
          break
        }
      }
    }
    return null
  }


  fn finishUnionInitializer(this, symbol, arguments, scope, argumentsPos, pos): ast.Node* {
    if arguments.length > 1 {
      this.cberr(argumentsPos, { type = symbol.instance.type, arguments = arguments.length }) with {
        println("expected 0 or 1 arguments for #{it.type} initializer\r\n\t\
          â†’ found: #{it.arguments}")
      }
      return this.throwAwayList(arguments)
    }

    if arguments.length == 0 {
      return this.make.initializer(arguments, symbol.instance.type, pos)
    }

    const argument = arguments.items[0]
    if const found = this.findSymbol(symbol.instance.type, argument.name, scope, argument.pos) {
      if const field = found.instance is ast.Field {
        argument.field = found
        if argument.value = this.make.cast(argument.value, field.type, argument.value.pos, isImplicit = false) {
          argument.type = argument.value.type
          return this.make.initializer(arguments, symbol.instance.type, pos)
        }
      } else this.cberr(argument.pos, { argument = argument.name, type = symbol.instance.type }) with {
        println("#{it.argument}#[%<darkred|white>] does not initialize a member field of #{it.type}")
      }
    } else {
      this.e_not_found(pos, symbol.instance.type, argument.name)
    }
    return this.throwAwayList(arguments)
  }


  fn finishFunctionInitializer(this, symbol, initializerArguments, scope, pos): ast.Node* {
    const arguments = List(ast.Argument*){}
    for initializerArgument in initializerArguments {
      if initializerArgument.type.isLoadable() {
        arguments.append(this.make.argument(
            initializerArgument.name,
            initializerArgument.value,
            initializerArgument.pos
          ))
      } else if const value = this.make.referenceOf(initializerArgument.value, initializerArgument.value.pos) {
        arguments.append(this.make.argument(initializerArgument.name, value, initializerArgument.pos))
      }
      initializerArgument.value = null
    }    
    this.throwAwayList(initializerArguments)
    const callee = this.make.name(symbol, pos)
    auto    site = this.makeCallSite(scope, pos)
    this.site = &site
    const (indirect, type) = instantiator.call(site, callee, arguments)
    return null if type.isUnknown()
    assert !indirect && symbol == type.isaSymbol()
    this.throwAwayList(arguments)
    const function = symbol.instance as ast.Function*
    const fnreturn = this.getFnReturnFrom(function, pos)
    if fnreturn.isKnown() {
      return this.make.name(symbol, pos)
    }
    return null
  }


  fn finishArrayInitializer(this, symbol, arguments, scope, pos): ast.Node* {
    if arguments.length {
      this.cberr(pos, arguments) with {
        println("array initializer arguments not allowed")
      }
      return this.throwAwayList(arguments)
    }
    return this.make.initializer(arguments, symbol.instance.type, pos)
  }


  fn finishObjectInitializer(this, symbol, arguments, scope, pos): ast.Node* {
    if arguments.length {
      this.cberr(pos, arguments) with {
        println("object initializer arguments not allowed")
      }
      return this.throwAwayList(arguments)
    }
    return this.make.initializer(arguments, symbol.instance.type, pos)
  }


  fn finishFixedArrayInitializer(this, symbol, arguments, scope, pos): ast.Node* {
    if arguments.length {
      this.cberr(pos, arguments) with {
        println("fixed-array initializer arguments not allowed")
      }
      return this.throwAwayList(arguments)
    }
    return this.make.initializer(arguments, symbol.instance.type, pos)
  }

  //-------------------------------------------------------------------------------------------------------
  fn finishDefinition(this, lhs, rhs, scope, pos): ast.Node* {
    return this.finishAssignment(lhs, rhs, scope, pos, ignoreConst = true, dereferenceLhs = false)
  }


  fn finishAssignment(this, lhs, rhs, scope, pos, ignoreConst = false, dereferenceLhs = true): ast.Node* {
    var lhsval = this.expectValue(lhs, scope)
    var rhsval = this.expectValue(rhs, scope, initializeIfType = true)
    if lhsval && dereferenceLhs {
      lhsval = this.make.directIfReference(lhsval)
    }
    if !lhsval || !rhsval {
      return this.throwAway2(lhsval, rhsval)
    }
    if lhsval.type.isaTuple() {
      return this.finishDestructure(lhsval, rhsval, scope, pos)
    }
    const   it = { lhs = *lhsval.type, op = Tok.Assign, rhs = *rhsval.type }
    if const c = sema.cast(it.lhs, it.rhs, isImplicit = false) {
      if rhsval = this.make.castWith(rhsval, it.lhs, c, rhsval.pos, isImplicit = false) {
        this.checkAssignability(lhsval, scope, ignoreConst)
        return this.make.assign(lhsval, rhsval, pos)
      }
      return this.throwAway(lhsval)
    }

    if const operator = this.findOperator(lhsval, it.op, scope) {
      return this.finishOperator(operator, rhsval, scope, pos)
    }

    this.cberr(pos, it) with {
      println("invalid assignment operation\r\n\t\
        â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
    }
    return this.throwAway2(lhsval, rhsval)
  }


  fn finishDestructure(this, lhs, rhs, scope, pos): ast.Node* {
    const rhsval = this.make.directIfReference(rhs) 
    if !rhsval {
      return this.throwAway(lhs)
    }
    if rhsval.type.isaTuple() {
      return this.destructure(lhs, rhsval, scope, pos)
    }
    this.cberr(pos, { lhs = lhs.type, rhs = rhsval.type }) with {
      println("illegal destructure\r\n\t\\r\n\t\
        â†’ expected: #{it.lhs} = #{it.lhs}
        â†’    found: #{it.lhs} = #{it.rhs}")
    }
    return this.throwAway2(lhs, rhsval)
  }


  fn destructure(this, lhs, rhs, scope, pos): ast.Node* {
    //  ( ... ) âŸµ ( ... )
    const lhsTuple = lhs.type.isaTuple()
    const rhsTuple = rhs.type.isaTuple()

    if lhsTuple.scope.symbols.length != rhsTuple.scope.symbols.length {
      this.cberr(pos, { lhs = lhsTuple.type, rhs = rhsTuple.type }) with {
        println("lhs and rhs of tuple destructure must be the same length\r\n\t\
          â†’ found: #{it.lhs} âŸµ #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    }

    /*             +--------------+
                   |      RHS     |
                   +-------+------+
                   | tuple | name |
       +---+-------+-------+------+
       | L | tuple |       |      |
       | H +-------+-------+------+
       | S | name  |       |      |
       +---+-------+-------+------+
    */
    if const lhsName = lhs is ast.Name {
      if lhsName.symbol.instance == lhsTuple {
        if const rhsName = rhs is ast.Name {
          if rhsName.symbol.instance == rhsTuple {
            this.throwAway2(lhsName, rhsName)
            return this.destructureFromTupleIntoTuple(lhsTuple, rhsTuple, scope, pos)
          }
        } else if const rhsCast = rhs is ast.Cast {
          if const      rhsName = rhsCast.value is ast.Name {
            if const tupleOfRhs = rhsName.type.isaTuple() {
              this.throwAway2(lhsName, rhsCast)
              return this.destructureFromTupleIntoTuple(lhsTuple, tupleOfRhs, scope, pos)
            }
          }
        } else if const rhsName = this.make.copyable(rhs, scope) {
          this.throwAway(lhsName)
          return this.destructureFromNameIntoTuple(lhsTuple, rhsName, rhsTuple, scope, pos)
        } else {
          return this.throwAway(lhsName)
        }
        this.cberr(pos, { lhs = lhs, rhs = rhs }) with {
          println("cannot destructure\r\n\
            â†’ found: lhs is a tuple but rhs is weird\r\n\
            â†’   rhs: #{nameof(it.rhs)}: #{it.rhs.type}")
        }
        this.throwAway2(lhs, rhs)
      }
    }

    if const rhsName = rhs is ast.Name {
      if rhsName.symbol.instance == rhsTuple {
        this.throwAway(rhsName)
        if const lhsName = this.make.copyable(lhs, scope) {
          return this.destructureFromTupleIntoName(lhsName, lhsTuple, rhsTuple, scope, pos)
        }
        return null
      }
    } else if const rhsCast = rhs is ast.Cast {
      if const      rhsName = rhsCast.value is ast.Name {
        if const tupleOfRhs = rhsName.type.isaTuple() {
          this.throwAway(rhsCast)
          if const lhsName = this.make.copyable(lhs, scope) {
            return this.destructureFromTupleIntoName(lhsName, lhsTuple, tupleOfRhs, scope, pos)
          }
          return null
        }
      }
    }

    /*if lhs !is ast.Call {
      this.cbinfo(pos, { lhs = lhs, rhs = rhs }) with {
        println("\r\n#{it.lhs.type} = #{it.rhs.type}\r\n\
          #{nameof(it.lhs)} = #{nameof(it.rhs)}")
        if const lhsName = it.lhs is ast.Name {
          if lhsName.symbol.instance {
            println("lhs.symbol = #{nameof(lhsName.symbol.instance)}")
          }
        }
        if const rhsName = it.rhs is ast.Name {
          if rhsName.symbol.instance {
            println("rhs.symbol = #{nameof(rhsName.symbol.instance)}")
          }
        }
      }
    }*/

    if const cast = this.make.cast(rhs, lhs.type, rhs.pos, isImplicit = false) {
      return this.make.assign(lhs, cast, pos)
    }
    return this.throwAway(lhs)

    /*const rhsName = this.make.copyable(rhs, scope)
    const lhsName = this.make.copyable(lhs, scope)
    return this.throwAway2(lhsName, rhsName) if !lhsName || !rhsName

    const    errors = this.typer.errors
    var assignments = List(ast.Node*){}
    for i, lhsItem in lhsTuple.scope.symbols {
      const lhsSymbol = lhsItem.value
      const rhsSymbol = rhsTuple.scope.symbols.items[i].value
      const  lhsField = lhsSymbol.instance as ast.Field*
      const  rhsField = rhsSymbol.instance as ast.Field*
      const  lhsValue = this.make.member(this.make.copy(lhsName, pos), lhsSymbol, pos)
      const  rhsValue = this.make.member(this.make.copy(rhsName, pos), rhsSymbol, pos)
      const    assign = this.finishDefinition(lhsValue, rhsValue, scope, pos)
      if assign {
        assignments.append(assign)
      }
    }
    this.throwAway2(lhsName, rhsName)
    if errors != this.typer.errors {
      return this.throwAwayList(assignments)
    }
    return this.make.destructure(lhsTuple.type, assignments, pos)*/
  }


  fn destructureFromTupleIntoTuple(this, lhsTuple, rhsTuple, scope, pos): ast.Node* {
    const    errors = this.typer.errors
    var assignments = List(ast.Node*){}
    for i, lhsItem in lhsTuple.scope.symbols {
      const lhsSymbol = lhsItem.value
      const rhsSymbol = rhsTuple.scope.symbols.items[i].value
      const  lhsField = lhsSymbol.instance as ast.Field*
      const  rhsField = rhsSymbol.instance as ast.Field*
      if const assign = this.finishDefinition(lhsField.value, rhsField.value, scope, lhsField.pos) {
        assignments.append(assign)
      }
      lhsField.value = this.make.zero(lhsField.type, lhsField.pos)
      rhsField.value = this.make.zero(rhsField.type, rhsField.pos)
    }
    if errors != this.typer.errors {
      return this.throwAwayList(assignments)
    }
    return this.make.destructure(lhsTuple.type, assignments, pos)
  }


  fn destructureFromNameIntoTuple(this, lhsTuple, name, rhsTuple, scope, pos): ast.Node* {
    const    errors = this.typer.errors
    var assignments = List(ast.Node*){}
    for i, lhsItem in lhsTuple.scope.symbols {
      const lhsSymbol = lhsItem.value
      const rhsSymbol = rhsTuple.scope.symbols.items[i].value
      const  lhsField = lhsSymbol.instance as ast.Field*
      const     value = this.make.member(this.make.copy(name, lhsField.pos), rhsSymbol, lhsField.pos)
      if const assign = this.finishDefinition(lhsField.value, value, scope, lhsField.pos) {
        assignments.append(assign)
      }
      lhsField.value = this.make.zero(lhsField.type, lhsField.pos)
    }
    this.throwAway(name)
    if errors != this.typer.errors {
      return this.throwAwayList(assignments)
    }
    return this.make.destructure(lhsTuple.type, assignments, pos)
  }


  fn destructureFromTupleIntoName(this, name, lhsTuple, rhsTuple, scope, pos): ast.Node* {
    const    errors = this.typer.errors
    var assignments = List(ast.Node*){}
    for i, lhsItem in lhsTuple.scope.symbols {
      const lhsSymbol = lhsItem.value
      const rhsSymbol = rhsTuple.scope.symbols.items[i].value
      const  rhsField = rhsSymbol.instance as ast.Field*
      const     value = this.make.member(this.make.copy(name, pos), lhsSymbol, pos)
      if const assign = this.finishDefinition(value, rhsField.value, scope, pos) {
        assignments.append(assign)
      }
      rhsField.value = this.make.zero(rhsField.type, rhsField.pos)
    }
    this.throwAway(name)
    if errors != this.typer.errors {
      return this.throwAwayList(assignments)
    }
    return this.make.destructure(lhsTuple.type, assignments, pos)
  }


  fn finishTildeAssign(this, lhsval, rhsval, scope, pos): ast.Node* {
    var lhs = this.expectValue(lhsval, scope)
    var rhs = this.expectValue(rhsval, scope, initializeIfType = true)
    if lhs {
      lhs = this.make.directIfIntegral(lhs)
    }
    if !lhs || !rhs {
      return this.throwAway2(lhs, rhs)
    }
    const ctx = { lhs = *lhs.type, op = Tok.TildeAssign, rhs = *rhs.type }

    if lhs.type.isNotIntegral() {      
      if const operator = this.findOperator(lhs, ctx.op, scope) {
        return this.finishOperator(operator, rhs, scope, pos)
      }
      this.cberr(pos, ctx) with {
        println("no operator exists for bitwise-not-assign operation\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    }

    if rhs = this.make.cast(rhs, lhs.type, rhs.pos, isImplicit = false) {
      this.checkAssignability(lhs, scope)
      return this.make.assignment(lhs, Tok.TildeAssign, rhs, pos)
    }
    return this.throwAway(lhs)
  }


  fn finishBitwise(this, lhsval, op, rhsval, scope, pos): ast.Node* {
    const isAssignment = op.isanAssignmentOperator()
    var            lhs = this.expectValue(lhsval, scope)
    var            rhs = this.expectValue(rhsval, scope, initializeIfType = isAssignment)
    if lhs {
      lhs = this.make.directIfNumeric(lhs)
    }
    if !lhs || !rhs {
      return this.throwAway2(lhs, rhs)
    }
    const ctx = { lhs = *lhs.type, op = op, rhs = *rhs.type }

    if lhs.type.isaPointer() {
      this.cberr(pos, ctx) with {
        println("invalid operation on pointer\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    }

    if lhs.type.isNotANumber() {
      if const operator = this.findOperator(lhs, ctx.op, scope) {
        return this.finishOperator(operator, rhs, scope, pos)
      }
      this.cberr(pos, ctx) with {
        println("no operator exists for bitwise operation\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    }

    if isAssignment {
      this.checkAssignability(lhs, scope)
      if rhs = this.make.cast(rhs, lhs.type, rhs.pos, isImplicit = false) {
        return this.make.assignment(lhs, ctx.op, rhs, pos)
      }
    } else {
      const ub = sema.upperBound(lhs.type, rhs.type)
      if ub.isNumeric() {
        lhs = this.make.cast(lhs, ub, lhs.pos, isImplicit = true)
        rhs = this.make.cast(rhs, ub, rhs.pos, isImplicit = true)
        if lhs && rhs {
          return this.make.arithmetic(lhs, ctx.op, rhs, lhs.type, pos)
        }
      } else this.cberr(pos, ctx) with {
        println("upper bound for bitwise operation not found\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
    }
    return this.throwAway2(lhs, rhs)
  }


  fn finishShift(this, lhsval, op, rhsval, scope, pos): ast.Node* {
    const isAssignment = op.isanAssignmentOperator()
    var            lhs = this.expectValue(lhsval, scope)
    var            rhs = this.expectValue(rhsval, scope, initializeIfType = isAssignment)
    if lhs {
      lhs = this.make.directIfIntegral(lhs)
    }
    if !lhs || !rhs {
      return this.throwAway2(lhs, rhs)
    }
    const it = { lhs = *lhs.type, op = op, rhs = *rhs.type }

    if it.lhs.isaPointer() {
      this.cberr(pos, it) with {
        println("invalid operation on pointer\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    }

    if it.lhs.isNotIntegral() {
      if const operator = this.findOperator(lhs, it.op, scope) {
        return this.finishOperator(operator, rhs, scope, pos)
      }
      this.cberr(pos, it) with {
        println("no operator exists for shift operation\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    }

    if isAssignment {
      this.checkAssignability(lhs, scope)
      if rhs = this.make.cast(rhs, it.lhs, rhs.pos, isImplicit = false) {
        return this.make.assignment(lhs, it.op, rhs, pos)
      }
    } else {
      const ub = sema.upperBound(it.lhs, it.rhs)
      if ub.isIntegral() {
        lhs = this.make.cast(lhs, ub, lhs.pos, isImplicit = true)
        rhs = this.make.cast(rhs, ub, rhs.pos, isImplicit = true)
        if lhs && rhs {
          return this.make.arithmetic(lhs, it.op, rhs, ub, pos)
        }
      } else this.cberr(pos, it) with {
        println("upper bound for addition shift not found\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
    }
    return this.throwAway2(lhs, rhs)
  }


  fn finishAddition(this, lhsval, op, rhsval, scope, pos): ast.Node* {
    const isAssignment = op.isanAssignmentOperator()
    var            lhs = this.expectValue(lhsval, scope)
    var            rhs = this.expectValue(rhsval, scope, initializeIfType = isAssignment)
    if lhs {
      lhs = this.make.directIfNumeric(lhs)
    }
    if rhs {
      rhs = this.make.directIfNumeric(rhs)
    }
    if !lhs || !rhs {
      return this.throwAway2(lhs, rhs)
    }
    const it = { lhs = *lhs.type, op = op, rhs = *rhs.type }

    if it.lhs.isaPointer() {
      if it.rhs.isIntegral() {
        //  lhs:T*  + rhs:I or
        //  lhs:T* += rhs:I or
        //  lhs:T*  - rhs:I or
        //  lhs:T* -= rhs:I
        return this.finishPointerIntegerAddition(it, lhs, rhs, scope, pos)
      }
      if it.rhs.isaPointer() {
        if it.op != Tok.Minus {
          this.cberr(pos, it) with {
            println("illegal pointer arithmetic\r\n\t\
              â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
          }
          return this.throwAway2(lhs, rhs)
        }
        //  lhs:T* - rhs:T*
        return this.finishPointerPointerSubtraction(it, lhs, rhs, scope, pos)
      }
      //  lhs:T* - rhs:I
      //  lhs:T* - rhs:T*
      this.cberr(pos, it) with {
        println("illegal pointer arithmetic\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    } 

    if it.rhs.isaPointer() {
      if it.lhs.isIntegral() && it.op == Tok.Plus {
        //  rhs:T* + lhs:I
        return this.finishPointerIntegerAddition(it, rhs, lhs, scope, pos)
      }
      this.cberr(pos, it) with {
        println("illegal pointer arithmetic\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    }

    if it.lhs.isNotNumeric() {
      if const operator = this.findOperator(lhs, it.op, scope) {
        return this.finishOperator(operator, rhs, scope, pos)
      }
      this.cberr(pos, it) with {
        println("no operator exists for addition operation\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    }

    if isAssignment {
      this.checkAssignability(lhs, scope)
      if rhs = this.make.cast(rhs, it.lhs, rhs.pos, isImplicit = false) {
        return this.make.assignment(lhs, it.op, rhs, pos)
      }
    } else {
      const ub = sema.upperBound(it.lhs, it.rhs)
      if ub.isNumeric() {
        lhs = this.make.cast(lhs, ub, lhs.pos, isImplicit = true)
        rhs = this.make.cast(rhs, ub, rhs.pos, isImplicit = true)
        if lhs && rhs {
          return this.make.arithmetic(lhs, it.op, rhs, ub, pos)
        }
      } else this.cberr(pos, it) with {
        println("upper bound for addition operation not found\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
    }
    return this.throwAway2(lhs, rhs)
  }


  fn finishPointerIntegerAddition(this, it, lhs, rhs, scope, pos): ast.Node* {
    const isAssignment = it.op == Tok.MinusAssign || it.op == Tok.PlusAssign
    // T* âŸµ T* + I
    // T* âŸµ T* - I
    if it.rhs.size() < sizeof(Int32) {
      if it.rhs.isSigned() {
        rhs = this.make.cast(rhs, ast.tyInt32, rhs.pos, isImplicit = true)
      } else {
        rhs = this.make.cast(rhs, ast.tyUInt32, rhs.pos, isImplicit = true)
      }
      if !rhs {
        return this.throwAway(lhs)
      }
    }
    if isAssignment {          
      this.checkAssignability(lhs, scope)
      return this.make.assignment(lhs, it.op, rhs, pos)
    }
    return this.make.arithmetic(lhs, it.op, rhs, lhs.type, pos) 
  }


  fn finishPointerPointerSubtraction(this, it, lhs, rhs, scope, pos): ast.Node* {    
    // Int64 âŸµ T* - T*
    const ub = sema.upperBound(it.lhs, it.rhs)
    if ub.isKnown() {
      lhs = this.make.cast(lhs, ub, lhs.pos, isImplicit = true)
      rhs = this.make.cast(rhs, ub, rhs.pos, isImplicit = true)
      if lhs && rhs {
        return this.make.arithmetic(lhs, it.op, rhs, ast.tyInt64, pos)
      }
    } else this.cberr(pos, it) with {
      println("'-' pointer operation on unrelated types\r\n\t\
        â†’ found: #{it.lhs} #{it.op.value()} #{it.rhs}")
    }
    return this.throwAway2(lhs, rhs)
  }


  fn finishMultiplicative(this, lhsval, op, rhsval, scope, pos): ast.Node* {
    const isAssignment = op.isanAssignmentOperator()
    var            lhs = this.expectValue(lhsval, scope)
    var            rhs = this.expectValue(rhsval, scope, initializeIfType = isAssignment)
    if lhs && isAssignment {
      lhs = this.make.directIfNumeric(lhs)
    }
    if !lhs || !rhs {
      return this.throwAway2(lhs, rhs)
    }
    const it = { lhs = *lhs.type, op = op, rhs = *rhs.type }

    if it.lhs.isaPointer() {
      this.cberr(pos, it) with {
        println("invalid operation on pointer\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    }

    if it.lhs.isNotNumeric() {
      if const operator = this.findOperator(lhs, it.op, scope) {
        return this.finishOperator(operator, rhs, scope, pos)
      }
      this.cberr(pos, it) with {
        println("no operator exists for multiplicative operation\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    }

    if isAssignment {
      this.checkAssignability(lhs, scope)
      if rhs = this.make.cast(rhs, it.lhs, rhs.pos, isImplicit = false) {
        return this.make.assignment(lhs, it.op, rhs, pos)
      }
    } else {
      const ub = sema.upperBound(it.lhs, it.rhs)
      if ub.isNumeric() {
        lhs = this.make.cast(lhs, ub, lhs.pos, isImplicit = true)
        rhs = this.make.cast(rhs, ub, rhs.pos, isImplicit = true)
        if lhs && rhs {
          return this.make.arithmetic(lhs, it.op, rhs, lhs.type, pos)
        }
      } else this.cberr(pos, it) with {
        println("upper bound for multiplicative operation not found\r\n\t\
          â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
      }
    }
    return this.throwAway2(lhs, rhs)
  }


  fn finishTo(this, lhsval, rhsval, scope, pos): ast.Node* {
    var lhs = this.expectValue(lhsval, scope)
    var rhs = this.expectType(rhsval)
    if !lhs || !rhs {
      return this.throwAway2(lhs, rhs)
    }
    if const value = this.make.bitcast(lhs, rhs.type, pos) {
      this.throwAway(rhs)
      return value
    }
    return this.throwAway(rhs)
  }


  fn finishAs(this, lhsval, rhsval, scope, pos): ast.Node* {
    var lhs = this.expectValue(lhsval, scope)
    var rhs = this.expectType(rhsval)
    if !lhs || !rhs {
      return this.throwAway2(lhs, rhs)
    }
    if const value = this.make.cast(lhs, rhs.type, pos, isImplicit = false) {
      this.throwAway(rhs)
      return value
    }
    return this.throwAway(rhs)
  }


  fn finishIs(this, lhsval, op, rhsval, scope, pos) {
    var lhs = this.expectValue(lhsval, scope)
    var rhs = this.expectType(rhsval)
    if !lhs || !rhs {
      return this.throwAway2(lhs, rhs)
    }
    const ctx = { lhs = *lhs.type, op = op, rhs = *rhs.type }
    if rhs.type.isIndirect() {
      this.cberr(rhs.pos, ctx) with {
        println("expected rhs of #{it.op.value()}#[%<white|red>] operator to be a direct type name\r\n\t\
        â†’ found: #{it.rhs}")
      }
      return this.throwAway2(lhs, rhs)
    }
    // lhs: T is U
    // Rewrite as:
    //    lhs.__is__( rhs.__typeid__ ) as U*
    //
    // lhs: T !is U
    // Rewrite as:
    //    !( lhs.__is__( rhs.__type__id ) as U* )
    const lhsTypeId = this.hasTypeIdField(lhs.type)
    const rhsTypeid = this.hasTypeIdField(rhs.type)    

    if lhsTypeId && rhsTypeid {
      if lhsTypeId == rhsTypeid {
        assert lhsTypeId.scope == rhsTypeid.scope
        if const   callee = this.findMember(lhs, this.ids.kw_is, scope, lhs.pos, pos) {
          const  argument = this.make.int(rhs.type.typeid(), rhs.pos)
          const arguments = List(ast.Argument*){}
          arguments.append(this.make.argument(this.typer.emptyid, argument, argument.pos))
          if const   call = this.finishCall(callee, arguments, scope, pos) {
            const pointer = this.typer.types.pointerOf(rhs.type)
            this.throwAway(rhs)
            if const cast = this.make.cast(call, pointer, call.pos, isImplicit = false) {
              if ctx.op == Tok.IsNot {
                return this.make.logicalNot(cast, cast.pos)
              }
              return cast
            }
          }
        }
        lhs = null // Because of {throwAway2} below.
      } else {
        this.cberr(pos, ctx) with {
          println("expected lhs and rhs of #{it.op.value()}#[%<white|red>] operator to be related\r\n\t\
            â†’ found: #{it.lhs} #{it.op.value()}#[%<white|red>] #{it.rhs}")
        }
      }
    } else if lhsTypeId {
      this.cberr(rhs.pos, ctx) with {
        println("rhs of type operator must be an abstract type\r\n\t\
          â†’ found: #{it.rhs} #{it.op.value()} #{it.rhs}")
      }
    } else {
      this.cberr(lhs.pos, ctx) with {
        println("lhs of type operator must be an abstract type\r\n\t\
          â†’ found: #{it.rhs} #{it.op.value()} #{it.rhs}")
      }
    }

    return this.throwAway2(lhs, rhs)
  }


  fn bindCondition(this, template, scope): ast.Node* {
    if const value = this.bind(template, scope) {
      if this.isNotACondition(value) {
        return this.finishLogicalIs(value, scope, mkPos(template))
      }
      return value
    }
    return null
  }


  fn finishCondition(this, lhsval, op, rhsval, scope, pos): ast.Node* {
    var lhs = this.expectValue(lhsval, scope)
    var rhs = this.expectValue(rhsval, scope)
    if !lhs || !rhs {
      return this.throwAway2(lhs, rhs)
    }
    const    ctx = { lhs = *lhs.type, op = op, rhs = *rhs.type }
    const errors = this.typer.errors

    if !ctx.op.isaLogicalBinaryOperator() {
      if lhs.type.isaPointer() {
        if rhs.type.isNotAPointer() {
          this.cberr(pos, ctx) with {
            println("invalid pointer comparison\r\n\t\
              â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
          }
        }
      } else if rhs.type.isaPointer() {
        this.cberr(pos, ctx) with {
          println("invalid pointer comparison\r\n\t\
            â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
        }
      }
    }

    if errors == this.typer.errors {
      lhs = this.make.directIfNumeric(lhs)
      rhs = this.make.directIfNumeric(rhs)
      if ctx.op == Tok.OrOr || ctx.op == Tok.AndAnd {
        if this.isNotACondition(lhs) {
          lhs = this.finishLogicalIs(lhs, scope, pos)
        }
        if this.isNotACondition(rhs) {
          rhs = this.finishLogicalIs(rhs, scope, pos)
        }
        if lhs && rhs {
          return this.make.binaryCondition(lhs, ctx.op, rhs, pos)
        }
      } else {
        const ub = sema.upperBound(lhs.type, rhs.type)
        if ub.isaPointerOrNumeric() {
          lhs = this.make.cast(lhs, ub, lhs.pos, isImplicit = true)
          rhs = this.make.cast(rhs, ub, rhs.pos, isImplicit = true)
          if lhs && rhs {
            return this.make.binaryCondition(lhs, ctx.op, rhs, pos)
          }
        } else if const operator = this.findOperator(lhs, ctx.op, scope) {
          return this.finishOperator(operator, rhs, scope, pos)
        } else this.cberr(pos, ctx) with {
          println("invalid condition\r\n\t\
            â†’ #{it.lhs} #{it.op.value()} #{it.rhs}")
        }
      }
    }
    return this.throwAway2(lhs, rhs)
  }


  fn isaCondition(this, node) {
    switch node {
      case ast.BinaryCondition return true
      case ast.UnaryCondition  return true
      case ast.Intrinsic       return node.keyword == this.ids.kw_atomic_cmpxchg
    }
    return false
  }


  fn isNotACondition(this, node) = !this.isaCondition(node)


  fn finishNew(this, node, arguments, scope, argumentsPos, pos): ast.Node* {
    /*  Translation ðŸ¡“
          t1:T* âŸµ malloc( T*{}, sizeof( T ) )  ; allocate memory. returns a pointer. (T*).
          t2:T  âŸµ * t1                         ; dereference t1.
          t2:T  âŸµ T{ ... }                     ; assign initializer to t2.
          t3:T* âŸµ & t2                         ; take address of t2 to return the pointer created (t1).
    */

    var value = this.expectType(node)
    return this.throwAwayList(arguments) if !value

    const type = *value.type
    this.throwAway(value)

    if const call = this.callMalloc(type, scope, pos) { // t1:T* âŸµ malloc( T*{}, sizeof( T ) )
      if type.isLoadable() {
        return this.finishNewOfLoadable(call, arguments, scope, argumentsPos, pos)
      }
      return this.finishNewOfUnloadable(call, arguments, scope, argumentsPos, pos)
    }
    return this.throwAwayList(arguments)
  }


  fn finishNewOfLoadable(this, call, arguments, scope, argumentsPos, pos): ast.Node* {
    const type = call.type.pointee()
    if arguments.length == 1 {
      /*  Translation ðŸ¡“
            t1:T* âŸµ malloc( T*{}, sizeof( T ) )
            t2:T  âŸµ * t1
            t2:T  âŸµ arg as T
            t3:T* âŸµ & t2
      */
      const argument = arguments.items[0]
      if argument.value = this.make.cast(argument.value, type, argument.pos, isImplicit = false) { // arg as T
        if const deref = this.make.dereferenceOf(call, pos) { // * t1
          const  value = argument.value
          argument.value = null
          this.throwAwayList(arguments)
          if const assign = this.finishAssignment(deref, value, scope, pos) {  // * t1 âŸµ arg as T
            return this.make.addressOf(assign, pos) // &( * t1 )
          }
          return null
        }
      }
      this.throwAwayList(arguments)
      return this.throwAway(call)
    }
    if arguments.length {
      this.cberr(pos, { ctx = this, type = type, arguments = arguments }) with {
        print("too many arguments for operator #{'new'}#[%<darkred|white>] on #{it.type}\r\n\t\
          â†’ expected: 0 or 1\r\n\t\
          â†’    found: #{it.arguments.length}")
        it.ctx.e_list_arguments(it.arguments)
      }
      this.throwAwayList(arguments)
      return this.throwAway(call)
    }
    return call
  }


  fn finishNewOfUnloadable(this, call, arguments, scope, argumentsPos, pos): ast.Node* {
    /*  Translation ðŸ¡“
          t1:T* âŸµ malloc( T*{}, sizeof( T ) )
          t2:T  âŸµ * t1
          t2:T  âŸµ { ... }
          t3:T* âŸµ & t2
    */
    const          type = call.type.pointee()
    if const      deref = this.make.dereferenceOf(call, pos) { // * t1
      if const     init = this.finishInitializer(type, arguments, scope, argumentsPos, pos) { // { ... }
        if const assign = this.finishAssignment(deref, init, scope, pos) { // * t1 âŸµ { ... }
          return this.make.addressOf(assign, pos) // & t2
        }
        this.throwAway(init)   
      }
      return this.throwAway(deref)
    }
    return this.throwAwayList(arguments)
  }


  fn finishDelete(this, value, withPart, scope, pos): ast.Node* {
    /*  +-------+------------------------------------+
        | T is  | Operation                          | Notes
        +-------+------------------------------------+
        | B|E   | x âŸµ zero                          | Assign zero to builtin or enum
        +-------+------------------------------------+
        | B&|E& | *x âŸµ zero                         | Dereference then assign zero
        +-------+------------------------------------+
        | T***  | x âŸµ zero                          |
        +-------+------------------------------------+
        | T*    | x: T* âŸµ mfree( x.dispose() if x ) | T has dispose method
        +       +------------------------------------+
        |       | x: T* âŸµ mfree( x )                | T does not have a dispose method
        +-------+------------------------------------+
        | T&    | x.dispose()                        | T has dispose method
        +       +------------------------------------+
        |       | Do nothing                         | T does not have a dispose method
        +-------+------------------------------------+
        | T     | x.dispose()                        |
        +-------+------------------------------------+
    */
    value = this.make.copyable(value, scope)
    return this.throwAway(withPart) if !value

    if value.type.isaBuiltin() || value.type.isanEnum() {
      if withPart {
        this.cberr(withPart.pos, value.type) with {
          println("#{it} cannot be disposed with arguments")
        }
        return this.throwAway2(value, withPart)
      }
      // value âŸµ zero
      return this.finishAssignment(value, this.make.zero(value.type, pos), scope, pos, ignoreConst = true)
    }

    if const ref = value.type.isaReference() {
      if ref.pointee.isaBuiltin() || ref.pointee.isanEnum() {        
        if withPart {
          this.cberr(withPart.pos, value.type) with {
            println("#{it} cannot be disposed with arguments")
          }
          return this.throwAway2(value, withPart)
        }
        // *value âŸµ zero
        if const deref = this.make.dereferenceOf(value, pos) {
          return this.finishAssignment(deref, this.make.zero(deref.type, pos), scope, pos, ignoreConst = true)
        }
        return null
      }
    } else if const ptr = value.type.isaPointer() {
      if ptr.pointee.isIndirect() {
        if withPart {
          this.cberr(withPart.pos, value.type) with {
            println("#{it} cannot be disposed with arguments")
          }
          return this.throwAway2(value, withPart)
        }
        // value âŸµ mfree( value )
        const    copy = this.make.copy(value, pos)
        if const call = this.callFree(value, scope, pos) {
          return this.finishAssignment(copy, call, scope, pos, ignoreConst = true)
        }
        return this.throwAway(copy)
      }
    }

    // Type of value is either T, T* or T& where T is neither B nor E.

    var     symDispose = ast.Symbol*{}
    var symDisposeWith = ast.Symbol*{}
    if const  indirect = value.type.isIndirect() {
      assert indirect.pointee.isDirect()
          symDispose = this.findSymbol(indirect.pointee, this.ids.kw_dispose, scope, pos)
      symDisposeWith = this.findSymbol(indirect.pointee, this.ids.kw_disposeWith, scope, pos)
    } else {
          symDispose = this.findSymbol(value.type, this.ids.kw_dispose, scope, pos)
      symDisposeWith = this.findSymbol(value.type, this.ids.kw_disposeWith, scope, pos)
    }

    if withPart {
      if symDisposeWith {
        // value âŸµ mfree( value.disposeWith( withPart ) ) if value
        return this.finishDispose(value, symDisposeWith, withPart, scope, pos)
      }
      this.cberr(withPart.pos, value.type) with {
        println("expected a type with a member function #{'disposeWith'}#[%<darkgreen|white>]\r\n\t\
          â†’ found: #{it}")
      }
      return this.throwAway2(value, withPart)
    }

    // value âŸµ mfree( value.dispose() ) if value
    if symDispose {
      return this.finishDispose(value, symDispose, withPart, scope, pos)
    }

    // value âŸµ mfree( value )
    if value.type.isaPointer() {
      const    copy = this.make.copy(value, pos)
      if const call = this.callFree(value, scope, pos) {
        return this.finishAssignment(copy, call, scope, pos, ignoreConst = true)
      }
      return this.throwAway(copy)
    }

    const zero = this.make.zero(value.type, pos)
    this.throwAway(value)
    return zero // Do nothing
  }


  fn finishDispose(this, value, disposeSymbol, withPart, scope, pos): ast.Node* {
    const copy = this.make.copy(value, pos)

    // value.dispose
    const callee = this.make.member(value, disposeSymbol, value.pos)

    // ( withPart )
    const arguments = List(ast.Argument*){}
    if withPart {
      arguments.append(this.make.argument(this.typer.emptyid, withPart, withPart.pos))
    }

    // value.dispose( withPart )
    var call = this.finishCall(callee, arguments, scope, pos)
    return this.throwAway(copy) if !call

    if copy.type.isNotAPointer() {
      // Stop here if {value} is not a T*
      this.throwAway(copy)
      return call
    }

    // Expect value.dispose( withPart ) to return a T* because {value} is a T*
    if call.type != copy.type {
      const ctx = { name = disposeSymbol.name, expected = copy.type, found = call.type }
      this.cberr(call.pos, ctx) with {
        println("expected the result of calling #{it.name}#[%<darkgreen|white>] to be #{it.expected}\r\n\t\
          â†’ found: #{it.found}")
      }
      return this.throwAway2(copy, call)
    }

    // mfree( value.dispose() )
    call = this.callFree(call, scope, pos)
    return this.throwAway(copy) if !call

    // mfree( value.dispose( withPart ) ) if value
    const condition = this.make.logicalIs(this.make.copy(copy, pos), pos)
    const    ifexpr = this.make.ifExpr(condition, call, pos)

    // value âŸµ mfree( value.dispose( withPart ) ) if value
    return this.finishAssignment(copy, ifexpr, scope, pos, ignoreConst = true)
  }


  fn callLock(this, value, scope, pos): ast.Node* {
    // value.lock
    const callee = this.findMember(value, this.ids.kw_lock, scope, pos, pos)
    return null if !callee

    // value.lock()
    const arguments = List(ast.Argument*){}
    return this.finishCall(callee, arguments, scope, pos)
  }


  fn callUnlock(this, value, scope, pos): ast.Node* {
    // value.unlock
    const callee = this.findMember(value, this.ids.kw_unlock, scope, pos, pos)
    return null if !callee

    // value.unlock()
    const arguments = List(ast.Argument*){}
    return this.finishCall(callee, arguments, scope, pos)
  }


  fn callAppend(this, base, value, scope, pos): ast.Node* {    
    // base.append
    const callee = this.findMember(base, this.ids.kw_append, scope, pos, pos)
    return null if !callee

    // base.append( value )
    const appendArguments = List(ast.Argument*){}
    appendArguments.append(
       this.make.argument(
            pos = pos,
           name = this.typer.emptyid,
          value = value
        )
      )
    return this.finishCall(callee, appendArguments, scope, pos)
  }


  fn callMalloc(this, type, scope, pos): ast.Node* {    
    if type.isVoid() || type.isaReference() {
      this.cberr(pos, type) with {
        println("invalid type for operator #{'new'}#[%<darkred|white>]\r\n\t\
          â†’ #{it}")
      }
      return null
    }

    // malloc
    const found = this.findInStd(this.ids.kw_memory, this.ids.kw_malloc, scope, pos)
    return null if !found

    const size = this.make.sizeOfType(type, pos)
    const  ptr = this.typer.types.pointerOf(type)
    if ptr.isUnknown() {
      this.cberr(size.pos, type) with {
        println("invalid type for operator #{'new'}#[%<darkred|white>]\r\n\t\
          â†’ #{it}")
      }
      return this.throwAway(size)
    }

    const      callee = this.make.name(found, size.pos)
    const nullPointer = this.make.zero(ptr, size.pos) // T*{}
    const   arguments = List(ast.Argument*){}
    arguments.append(this.make.argument(this.typer.emptyid, nullPointer, nullPointer.pos))
    arguments.append(this.make.argument(this.typer.emptyid, size, size.pos))
    const call = this.finishCall(callee, arguments, scope, pos)
    return null if !call

    assert call.type == ptr

    return call
  }


  fn callFree(this, value, scope, pos) {
    assert value.type.isaPointer()

    // mfree
    const found = this.findInStd(this.ids.kw_memory, this.ids.kw_mfree, scope, pos)
    if !found {
      return this.throwAway(value)
    }

    const type = *value.type

    // cast âŸµ value as Void*
    const cast = this.make.cast(value, this.typer.tyNull, pos, isImplicit = true)
    assert cast

    // ( cast )
    const arguments = List(ast.Argument*){}
    arguments.append(this.make.argument(this.typer.emptyid, cast, pos))

    // mfree( cast )
    if const call = this.finishCall(this.make.name(found, pos), arguments, scope, pos) {
      assert call.type.isNull()
      // mfree( cast ) as T*
      return this.make.cast(call, type, pos, isImplicit = true)
    }
    return null
  }


  fn finishLogicalIs(this, node, scope, pos): ast.Node* {
    /*  Translation ðŸ¡“
          !! value: T
        Require ðŸ¡“
          Â· {value} is not a typename
          Â· {T} is Â· not Void and is either
                   Â· a pointer or
                   Â· a numeric or
                   Â· a UDT with {!!} defined
    */
    var value = this.expectValue(node, scope)
    return null if !value

    value = this.make.directIfNumeric(node)
    if const condition = value is ast.UnaryCondition {
      if condition.op == Tok.LogicalNot {
        // !! (! value: T) remains ! value: T
      } else if condition.op == Tok.LogicalIs {
        // !! (!! value: T) remains !! value: T
      } else {
        assert 0
      }
      return value
    }

    if const intrinsic = value is ast.Intrinsic {
      if intrinsic.keyword == this.ids.kw_atomic_cmpxchg {
        // !! __atomic_cmpxchg__( value: T*, comparand: T, exchange: T) remains as is
        return value
      }
    }

    if value.type.isLoadable() && value.type.isNotAReference() {
      return this.make.logicalIs(value, pos)
    }
    if const operator = this.findOperator(value, Tok.LogicalIs, scope) {
      if const result = this.finishOperator(operator, ast.Node*{}, scope, pos) {
        return this.make.cast(result, ast.tyBool, pos, isImplicit = true)
      }
      return null
    }
    this.cberr(pos, value) with {
      println("no boolean cast exists for #{it.type} in 'logical is' context")
    }
    return this.throwAway(value)
  }


  fn finishLogicalNot(this, node, scope, pos): ast.Node* {
    /*  Translation ðŸ¡“
          ! value: T
        Require:  Â· {value} is not a typename
                  Â· {T} is not Void
                  Â· {T} is Â· a pointer or
                           Â· a numeric or
                           Â· a UDT with {!} defined
    */
    var value = this.expectValue(node, scope)
    return null if !value

    value = this.make.directIfNumeric(node)
    if const condition = value is ast.UnaryCondition {
      if condition.op == Tok.LogicalNot {
        // ! (! value: T) becomes !! value: T
        condition.op = Tok.LogicalIs
      } else if condition.op == Tok.LogicalIs {
        // ! (!! value: T) becomes ! value: T
        condition.op = Tok.LogicalNot
      } else {
        assert 0
      }
      return value
    }

    if value.type.isLoadable() && value.type.isNotAReference() {
      return this.make.logicalNot(value, pos)
    }
    if const operator = this.findOperator(value, Tok.LogicalNot, scope) {
      if const result = this.finishOperator(operator, ast.Node*{}, scope, pos) {
        return this.make.cast(result, ast.tyBool, pos, isImplicit = true)
      }
      return null
    }
    this.cberr(pos, value) with {
      println("no boolean cast exists for #{it.type} in 'logical not' context")
    }
    return this.throwAway(value)
  }


  fn negateCondition(this, condition): ast.Node* {
    switch condition {
      case ast.BinaryCondition {
        switch condition.op {
          case Tok.OrOr {
            //  ! ( lhs || rhs ) becomes !lhs && !rhs
            condition.lhs = this.negateCondition(condition.lhs)
            condition.rhs = this.negateCondition(condition.rhs)
            if condition.lhs && condition.rhs {
              condition.op = Tok.AndAnd
              return condition
            }
          }
          case Tok.AndAnd {
            //  ! ( lhs && rhs ) becomes !lhs || !rhs
            condition.lhs = this.negateCondition(condition.lhs)
            condition.rhs = this.negateCondition(condition.rhs)
            if condition.lhs && condition.rhs {
              condition.op = Tok.OrOr
              return condition
            }
          }
          case Tok.Equal          { condition.op = Tok.NotEqual       return condition }
          case Tok.NotEqual       { condition.op = Tok.Equal          return condition }
          case Tok.Equivalent     { condition.op = Tok.Equivalent     return condition }
          case Tok.NotEquivalent  { condition.op = Tok.Equivalent     return condition }
          case Tok.Less           { condition.op = Tok.GreaterOrEqual return condition }
          case Tok.LessOrEqual    { condition.op = Tok.Greater        return condition }
          case Tok.Greater        { condition.op = Tok.LessOrEqual    return condition }
          case Tok.GreaterOrEqual { condition.op = Tok.Less           return condition }
          default this.cberr(condition.pos, condition) with {
            println("cannot negate binary condition because the operator is not known\r\n\t\
              â†’ found: #{it.lhs.type} #{it.op.value()} #{it.rhs.type}")
          }
        }
      }
      case ast.UnaryCondition {
        if condition.op == Tok.LogicalNot {
          // ! (! condition ) becomes !! condition
          condition.op = Tok.LogicalIs
          return condition
        } 
        if condition.op == Tok.LogicalIs {
          // ! (!! condition ) becomes ! condition
          condition.op = Tok.LogicalNot
          return condition
        }
      }
      case ast.Intrinsic {
        if condition.keyword == this.ids.kw_atomic_cmpxchg {
          // ! __atomic_cmpxchg__
          return this.make.logicalNot(condition, condition.pos)
        }
      }
    }
    this.cberr(condition.pos, condition) with {
      println("cannot negate condition because it is not a condition\r\n\t\
        â†’ found: #{nameof(it)}: #{it.type}")
    }
    return this.throwAway(condition)
  }

//----------------------------------------------------------------------------------------------------------
  fn mkTypeName(this, template, scope): ast.Node* {
    const pos = mkPos(template)
    const (symbol, duplicate) = scope.appendTypeTemplate(template.name, template, isaTypeExpression = true)
    if duplicate {
      this.e_exists(pos, template.name, duplicate)
      return null
    }
    if const result = this.tryInstantiate(symbol, scope, pos) {
      return this.make.name(result, mkPos(template))
    }
    return null
  }


  //-------------------------------------------------------------------------------------------------------
  fn expectValue(this, value, scope, initializeIfType = false): ast.Node* {
    return value if !value || value.type.isaFunctionSymbol() 
    if value.isaTypeName() {
      if initializeIfType {
        const arguments = List(ast.InitializerArgument*){}
        const    result = this.finishInitializer(value.type, arguments, scope, value.pos, value.pos)
        this.throwAway(value)
        return result
      }
      this.cberr(value.pos, value.type) with {
        println("expected a value, found the typename #{it}")
      }
      return this.throwAway(value)
    }
    return value
  }


  fn expectType(this, value): ast.Node* {
    return null if !value
    if value.isaTypeName() {
      return value
    }
    this.cberr(value.pos, value.type) with {
      println("expected a type name, found a value of #{it}")
    }
    return this.throwAway(value)
  }


  //--------------------------------------------------------------------------------------------------------
  fn mkPos(template) {
    const firstPos = template.pos
    const  lastPos = src.nlastpos(template)
    assert firstPos.file == lastPos.file && firstPos.file >= 0
    return Pos {
      file  = firstPos.file,
      range = Range {
        start = firstPos.range.start,
        end   = lastPos.range.end
      }
    }
  }


  fn currentFunction(scope) {
    return scope.parentFunction()
  }


  fn hasTypeIdField(this, type) {
    if const ptr = type.isIndirect() {
      if const st = ptr.pointee.isaStruct() {
        return st.scope.findLocal(this.ids.kw_typeid, asDotOperator = true)
      }
    } else if const st = type.isaStruct() {
      return st.scope.findLocal(this.ids.kw_typeid, asDotOperator = true)
    }
    return null
  }


  fn hasCyclesInSuper(derived, base) {
    return true if derived == base
    for st in derived.supers {
      return true if hasCyclesInSuper(st, base)
    }
    return false
  }


  fn hasChildren(node) {
    return node && node.children.length
  }


  fn doesNotHaveChildren(node) = !hasChildren(node)


  fn throwAway(node): ast.Node* {
    ast.ndispose(node) if node
    return null
  }


  fn throwAway2(node1, node2): ast.Node* {
    ast.ndispose(node1) if node1
    ast.ndispose(node2) if node2
    return null
  }


  fn throwAwayList(list): ast.Node* {
    ast.ldispose(list)
    return null
  }

//----------------------------------------------------------------------------------------------------------
  fn info(this, pos, msg) {
    this.typer.info(pos, msg)
  }


  fn cbinfo(this, pos, ctx, cb) {
    this.typer.cbinfo(pos, ctx, cb)
  }


  fn err(this, pos, msg) {
    this.typer.err(pos, msg)
  }


  fn cberr(this, pos, ctx, cb) {
    this.typer.cberr(pos, ctx, cb)
  }


  fn e_exists(this, pos, name, found) {
    this.typer.e_exists(pos, name, found)
  }


  fn e_not_found(this, pos, type, name) {
    this.typer.cberr(pos, { type = type, name = name }) with {
      if it.type.isUnknown() {
        println("identifier #{it.name}#[%<darkred|white>] not found")
      } else {
        println("identifier #{it.name}#[%<darkred|white>] not found in #{it.type}")
        if const scope = it.type.getLookupScope() {
          println("Symbols in lookup scope:")
          for item in scope.symbols {
            const symbol = item.value
            println("\t#{symbol.name}:#{symbol.type()}")
          }
        }
      }
    }
  }


  fn e_list_arguments(this, arguments, isInitializerArguments = false) {
    if isInitializerArguments {
      print("{")
    } else {
      print("(")
    }
    for i, argument in arguments {
      if i {
        print(", ")
      }
      print("#{argument.type}")
    }
    if isInitializerArguments {
      println("}")
    } else {
      println(")")
    }
  }


  //-------------------------------------------------------------------------------------------------------
  fn visitGenerator(this, functionSymbol):void {
    /*  fn f( ...parameters... ): Generator* {
          const local âŸµ malloc( Generator*{}, sizeof( Generator ) )
               *local âŸµ { iocallback, next, dispose, getioreturn, ...parameters... }
               retval âŸµ local
        }
    */
    const template = functionSymbol.template as src.Function*
    const function = functionSymbol.instance as ast.Function*
    const      pos = this.make.entryPos(function.scope.pos)
    //println("#{'doing'}#[%<blue|white>] #{function.type}")
    const      rsvd = this.enterScope(function.scope, ast.Scope*{})
    const generator = this.createGeneratorObject(functionSymbol)
    if const   call = this.callMalloc(generator.type, function.scope, pos) {
      const   local = this.make.local(constModifiers, this.ids.kw_it, call.type, function.scope, pos, pos)
      var    assign = this.finishAssignment(this.make.name(local, pos), call, function.scope, pos, ignoreConst = true)
      function.scope.appendStatement(assign)
      this.createGeneratorInitializer(local, generator, function, pos)
      function.fnreturn = call.type
      if const   retval = this.make.retval(function, call.type, function.scope, pos) {
                 assign = this.finishAssignment(retval, this.make.name(local, pos), function.scope, pos)
        function.scope.appendStatement(assign)
      }
    }
    this.leaveScope(rsvd)
    //println("#{' done'}#[%<yellow|black>] #{function.type}")  

    this.finishGeneratorNext(generator, functionSymbol)
    this.finishGeneratorCallBack(generator)
    this.finishGeneratorDispose(generator)
  }

  fn createGeneratorObject(this, functionSymbol): ast.Object* {
    const   template = functionSymbol.template as src.Function*
    const   function = functionSymbol.instance as ast.Function*
    const     symbol = this.make.generator(function.scope, mkPos(template))
    const  generator = symbol.instance as ast.Object*
    const       type = this.typer.types.pointerOf(generator.type)
    const autoDelete = template.modifiers.isAuto

    generator.kind = generator.Kind.Generator

    // generator.overlapped âŸµ os.OVERLAPPED{}
    var found = this.findInStd(this.ids.kw_os, this.ids.kw_OVERLAPPED, function.scope, generator.pos)
    return null if !found
    var value = this.make.zero(found.type(), generator.pos) as ast.Node*
    this.make.field(constModifiers, this.ids.kw_overlapped, value, generator.scope, generator.pos)

    // generator.iocallback âŸµ fn (self: Generator*, iotransferred: Int32, ioesult: Int32 ) {}
    var callbackSymbol = this.make.function(template, this.ids.kw_iocallback, function.scope, withExit = false)
                 value = this.make.name(callbackSymbol, generator.pos)
    this.make.field(noModifiers, this.ids.kw_iocallback, value, generator.scope, generator.pos)
    var         callback = callbackSymbol.instance as ast.Function*
    var            param = this.make.parameter(constModifiers, this.ids.kw_self, type, generator.pos)
    var (parameter, dup) = callback.scope.appendSymbol(param.name, this.typer.nullTemplate, param)
    callback.parameters.append(parameter)
    callback.fnreturn = ast.tyVoid

               param = this.make.parameter(constModifiers, this.ids.kw_iotransferred, ast.tyInt32, generator.pos)
    (parameter, dup) = callback.scope.appendSymbol(param.name, this.typer.nullTemplate, param)
    callback.parameters.append(parameter)
    
               param = this.make.parameter(constModifiers, this.ids.kw_ioresult, ast.tyInt32, generator.pos)
    (parameter, dup) = callback.scope.appendSymbol(param.name, this.typer.nullTemplate, param)
    callback.parameters.append(parameter)

    // generator.iotransferred âŸµ 0
    value = this.make.int(0, generator.pos)
    this.make.field(noModifiers, this.ids.kw_iotransferred, value, generator.scope, generator.pos)

    // generator.ioresult âŸµ 0
    value = this.make.int(0, generator.pos)
    this.make.field(noModifiers, this.ids.kw_ioresult, value, generator.scope, generator.pos)

    // generator.ioawaiter âŸµ null
    value = this.make.zero(this.typer.tyNull, generator.pos)
    this.make.field(noModifiers, this.ids.kw_ioawaiter, value, generator.scope, generator.pos)

    // generator.ioawaited âŸµ null
    value = this.make.zero(this.typer.tyNull, generator.pos)
    this.make.field(noModifiers, this.ids.kw_ioawaited, value, generator.scope, generator.pos)

    // generator.next âŸµ fn (self: Generator* ) {}
    callbackSymbol = this.make.function(template, this.ids.kw_next, function.scope, withExit = true)
             value = this.make.name(callbackSymbol, generator.pos)
    this.make.field(constModifiers, this.ids.kw_next, value, generator.scope, generator.pos)
            callback = callbackSymbol.instance as ast.Function*
               param = this.make.parameter(constModifiers, this.ids.kw_self, type, generator.pos)
    (parameter, dup) = callback.scope.appendSymbol(param.name, this.typer.nullTemplate, param)
    callback.parameters.append(parameter)

    // generator.dispose âŸµ fn (self: Generator* ) {}
    callbackSymbol = this.make.function(template, this.ids.kw_dispose, function.scope, withExit = false)
             value = this.make.name(callbackSymbol, generator.pos)
    this.make.field(constModifiers, this.ids.kw_dispose, value, generator.scope, generator.pos)
            callback = callbackSymbol.instance as ast.Function*
               param = this.make.parameter(constModifiers, this.ids.kw_self, type, generator.pos)
    (parameter, dup) = callback.scope.appendSymbol(param.name, this.typer.nullTemplate, param)
    callback.parameters.append(parameter)
    callback.fnreturn = type

    // generator.getioreturn âŸµ fn (self: Generator* ) {}
    callbackSymbol = this.make.function(template, this.ids.kw_getioreturn, function.scope, withExit = false)
             value = this.make.name(callbackSymbol, generator.pos)
    this.make.field(constModifiers, this.ids.kw_getioreturn, value, generator.scope, generator.pos)
            callback = callbackSymbol.instance as ast.Function*
               param = this.make.parameter(constModifiers, this.ids.kw_self, type, generator.pos)
    (parameter, dup) = callback.scope.appendSymbol(param.name, this.typer.nullTemplate, param)
    callback.parameters.append(parameter)

    // generator.ioreturn âŸµ false
    value = this.make.bool(false, generator.pos)
    this.make.field(noModifiers, this.ids.kw_ioreturn, value, generator.scope, generator.pos)

    // generator.ioresume âŸµ 0
    value = this.make.int(0, generator.pos)
    this.make.field(noModifiers, this.ids.kw_ioresume, value, generator.scope, generator.pos)

    // generator.iostopped âŸµ false
    value = this.make.bool(false, generator.pos)
    this.make.field(noModifiers, this.ids.kw_iostopped, value, generator.scope, generator.pos)

    // generator.exitReason âŸµ ExitReason.Flow
    value = this.make.byte(ExitReason.Flow, generator.pos)
    this.make.field(noModifiers, this.ids.kw_exitReason, value, generator.scope, generator.pos)

    // generator.autoDelete âŸµ autoDelete
    value = this.make.bool(autoDelete, generator.pos)
    this.make.field(noModifiers, this.ids.kw_autoDelete, value, generator.scope, generator.pos)

    return generator
  }


  fn createGeneratorInitializer(this, local, generator, function, pos) {
    const arguments = List(ast.InitializerArgument*){}
    
    appendGeneratorInitializerArgument(this.make, arguments, generator.scope.findLocal(this.ids.kw_iocallback), pos)
    appendGeneratorInitializerArgument(this.make, arguments, generator.scope.findLocal(this.ids.kw_next), pos)
    appendGeneratorInitializerArgument(this.make, arguments, generator.scope.findLocal(this.ids.kw_dispose), pos)
    appendGeneratorInitializerArgument(this.make, arguments, generator.scope.findLocal(this.ids.kw_getioreturn), pos)
    
    for parameter in function.parameters {
      const found = function.scope.findLocal(parameter.name)
      if !found {
        this.e_not_found(pos, function.type, parameter.name)
        continue
      }
      const  node = parameter.instance as ast.Parameter*
      const field = this.make.field(node.modifiers, parameter.name, this.make.name(found, pos),
        generator.scope, pos)
      continue if !field

      appendGeneratorInitializerArgument(this.make, arguments, field, pos)
    }
    const assign = this.finishAssignment(
        this.make.dereferenceOf(this.make.name(local, pos), pos),
        this.make.initializer(arguments, generator.type, pos),
        function.scope,
        pos,
        ignoreConst = true
      )
    function.scope.appendStatement(assign)

    fn appendGeneratorInitializerArgument(make, arguments, field, pos) {
      arguments.append(
          make.initializerArgumentWithField(field, pos)
        )
    }
  }


  fn finishGeneratorNext(this, generator, templateSymbol) {
    const template = templateSymbol.template as src.Function*
    const    field = generator.scope.findLocal(this.ids.kw_next)
    const function = field.instance.type.isaFunction()
    const    scope = function.scope
    const    rsvd1 = this.enterScope(scope, ast.Scope*{})

    function.generator = generator

    assert template.block

    if template.fnreturn {
      this.setIoReturnTypeFromFnReturn(function, template.fnreturn)
    }

    // if !self.ioresume { goto autoDelete if self.iostopped else goto els }
    const        top = this.make.entryPos(template.block.pos)
    const        btm = template.block.closeCurly
    const autoDelete = this.make.label(top)
    const        els = this.make.label(top)
    const     ifnode = this.make.ifStmt(scope, top, withExit = false, withExitInParent = false)
    scope.appendStatement(ifnode)
    const rsvd2 = this.enterScope(ifnode, scope)
    ifnode.condition = this.make.logicalNot(
        this.make.io(function, this.ids.kw_ioresume, top),
        top
      )
    ifnode.appendStatement(
        this.make.fullIfExpr(
                  pos = top,
               ifalse = this.make.goto(els, top),
               iftrue = this.make.goto(autoDelete, top),
            condition = this.make.logicalIs(this.make.io(function, this.ids.kw_iostopped, top), top)
          )
      )
    this.leaveScope(rsvd2)

    scope.appendStatement(els)

           els.id = ++function.labelIds
    autoDelete.id = ++function.labelIds

    function.generatorLabels.entry = els
     function.generatorLabels.exit = autoDelete

    // ...statements...
    this.visitScope(template.block, rsvd1)

    // self.ioresume âŸµ 0
    var assign = this.finishAssignment(
        this.make.io(function, this.ids.kw_ioresume, btm),
        this.make.int(0, btm),
        scope,
        btm
      )
    scope.appendStatement(assign)
    // exit: ...deferreds...
    this.takeDeferreds(scope)

    // self.ioreturn âŸµ ( ..., true ); retval âŸµ *&self.ioreturn
    this.resetIoReturnValue(function, btm)

    // if self.iostopped { self.ioresume âŸµ 0; goto autoDelete }
    this.gotoAutoDeleteIfStopped(function, btm)

    // self.iostopped âŸµ true
    assign = this.finishAssignment(
        this.make.io(function, this.ids.kw_iostopped, btm),
        this.make.bool(true, btm),
        scope,
        btm
      )
    scope.appendStatement(assign)

    this.lastAdvance(function, btm)

    // autoDelete: ( self = mfree( self ) ) if self.autoDelete
    this.finishAutoDeleteGenerator(function, btm)

    // return retval
    this.setReturnValue(function, this.make.io(function, this.ids.kw_ioreturn, btm), scope, btm)

    this.leaveScope(rsvd1)
  }


  fn finishGeneratorCallBack(this, generator) {
    const    field = generator.scope.findLocal(this.ids.kw_iocallback)
    const function = field.instance.type.isaFunction()
    const      pos = function.pos
    const     rsvd = this.enterScope(function.scope, ast.Scope*{})
    //println("#{'doing'}#[%<blue|white>] #{function.type}")
    const iotransferred = function.parameters.items[1]
    const      ioresult = function.parameters.items[2]

    // self.iotransferred âŸµ iotransferred if !self.iotransferred
    var ifExpr = this.make.ifExpr(
        condition = this.make.logicalNot(this.make.io(function, this.ids.kw_iotransferred, pos), pos),
           iftrue = this.make.name(iotransferred, pos),
              pos = pos
      )
    ifExpr.ifalse = this.make.io(function, this.ids.kw_iotransferred, pos)
    function.scope.appendStatement(
      this.finishAssignment(
          this.make.io(function, this.ids.kw_iotransferred, pos),
          ifExpr,
          function.scope,
          pos
        )
      )

    // self.ioresult âŸµ ioresult if !self.ioresult else self.ioresult
    ifExpr = this.make.ifExpr(
        condition = this.make.logicalNot(this.make.io(function, this.ids.kw_ioresult, pos), pos),
           iftrue = this.make.name(ioresult, pos),
              pos = pos
      )
    ifExpr.ifalse = this.make.io(function, this.ids.kw_ioresult, pos)
    function.scope.appendStatement(
      this.finishAssignment(
          this.make.io(function, this.ids.kw_ioresult, pos),
          ifExpr,
          function.scope,
          pos
        )
      )

    // self.next()
    const      next = this.make.io(function, this.ids.kw_next, pos)
    const arguments = List(ast.Argument*){}
    function.scope.appendStatement(this.finishCall(next, arguments, function.scope, pos))
    //println("#{' done'}#[%<yellow|black>] #{function.type}")
    this.leaveScope(rsvd)
  }


  fn finishGeneratorDispose(this, generator) {
    const    field = generator.scope.findLocal(this.ids.kw_dispose)
    const function = field.instance.type.isaFunction()
    const      pos = function.pos
    const    rsvd1 = this.enterScope(function.scope, ast.Scope*{})
    //println("#{'doing'}#[%<blue|white>] #{function.type}")
    const ioself = function.parameters.items[0]

    /*  if self.ioresume {
          self.iostopped âŸµ true
          self.next()
        }
        retval âŸµ self
    */

    const ifnode = this.make.ifStmt(function.scope, pos, withExit = false, withExitInParent = false)
    const  rsvd2 = this.enterScope(ifnode, function.scope)
    function.scope.appendStatement(ifnode)
    ifnode.condition = this.make.logicalIs(this.make.io(function, this.ids.kw_ioresume, pos), pos)
    ifnode.appendStatement(
        this.finishAssignment(
            this.make.io(function, this.ids.kw_iostopped, pos),
            this.make.bool(true, pos),
            ifnode,
            pos
          )
      )
    const      next = this.make.io(function, this.ids.kw_next, pos)
    const arguments = List(ast.Argument*){}
    ifnode.appendStatement(this.finishCall(next, arguments, ifnode, pos))
    this.leaveScope(rsvd2)

    function.scope.appendStatement(
        this.finishAssignment(
            this.make.retval(function, ioself.instance.type, function.scope, pos),
            this.make.name(ioself, pos),
            function.scope,
            pos
          )
      )
    //println("#{' done'}#[%<yellow|black>] #{function.type}")
    this.leaveScope(rsvd1)
  }


  fn finishGeneratorGetIoReturn(this, generator) {
    const    field = generator.scope.findLocal(this.ids.kw_getioreturn)
    const function = field.instance.type.isaFunction()
    const      pos = function.pos
    const    rsvd1 = this.enterScope(function.scope, ast.Scope*{})
    // retval âŸµ &*self.ioreturn
    const    ioreturn = this.make.io(function, this.ids.kw_ioreturn, pos)
    function.fnreturn = this.typer.types.referenceOf(ioreturn.type)
    function.scope.appendStatement(
        this.finishDefinition(
            this.make.retval(function, function.fnreturn, function.scope, pos),
            this.make.referenceOf(ioreturn, pos),
            function.scope,
            pos
          )
      )
    this.leaveScope(rsvd1)
  }


  fn bindGeneratorReturn(this, function, template, scope):void {
    /*  Translation ðŸ¡“
          self.ioresume âŸµ label.id
          self.ioreturn âŸµ ( value, true )
                 retval âŸµ *&self.ioreturn
          if self.ioawaiter {
              const local âŸµ self.ioawaiter as Generator*
            local.awaited âŸµ self
            local.next()
          }
          yield
          label:
            self.exitReason âŸµ ExitReason.Return
            goto scopeExit
    */
    const   pos = mkPos(template)
    const label = this.make.label(pos)
       label.id = ++function.labelIds

    // self.ioresume âŸµ label.id
    this.setIoResume(function, label, scope, pos)

    if template.value {
      if const value = this.bind(template.value, scope) {
        // self.ioreturn âŸµ ( value, true )
        this.setIoReturnValue(function, value, true, scope, pos)
      }
    } else {
        // self.ioreturn âŸµ ( void, true )
      this.setIoReturnValue(function, this.make.zero(ast.tyVoid, pos), true, scope, pos)
    }

    // if self.ioawaiter { ...next() }
    this.advanceAwaiter(function, scope, pos)

    // yield
    this.createYield(function, label, scope, pos)

    // self.exitReason âŸµ ExitReason.Return
    this.setExitReason(ExitReason.Return, scope, pos)

    // goto exitInParent
    this.breakFlow(scope, pos)
  }


  fn bindYieldStatement(this, function, template, scope):void {
    const   pos = mkPos(template)
    const label = this.make.label(pos)
       label.id = ++function.labelIds

    // self.ioresume âŸµ label.id
    this.setIoResume(function, label, scope, pos)

    if template.value {
      if const value = this.bind(template.value, scope) {
        // self.ioreturn âŸµ ( value, false )
        this.setIoReturnValue(function, value, false, scope, pos)
      }
    } else {
        // self.ioreturn âŸµ ( void, false )
      this.setIoReturnValue(function, this.make.zero(ast.tyVoid, pos), false, scope, pos)
    }

    // if self.ioawaiter { ...next() }
    this.advanceAwaiter(function, scope, pos)

    // yield
    this.createYield(function, label, scope, pos)

    // if self.iostopped { ... }
    this.exitIoIfStopped(function, scope, pos)
  }


  fn bindYieldFromStatement(this, function, template, outer):void {
    if !template.value {
      this.cberr(mkPos(template), null) with {
        println("#{'yield from'}#[%<darkred|white>] must have an rhs expression")
      }
      return
    }
    const block = this.make.block(outer, mkPos(template))
    const rsvd1 = this.enterScope(block, outer)
    var    loop = this.make.loop(block, block.pos)
    var   taken = false // Was {loop} put in {block}?
    const   pos = block.pos
    for {
      // bind( value )
      const value = this.bind(template.value, block)
      break if !value
      taken = true

      // loopEntry: loop
      block.appendStatement(loop.entry)
      block.appendStatement(loop)

      // if true {
      loop.condition = this.make.logicalIs(this.make.trueBool(value.pos), pos)
      const    rsvd2 = this.enterScope(loop, block)

      // callee âŸµ value.next
      const calleeBase = this.make.copyable(value, loop)
      const     callee = this.findMember(calleeBase, this.ids.kw_next, loop, calleeBase.pos, calleeBase.pos)
      break if !callee

      // call âŸµ value.next()
      const arguments = List(ast.Argument*){}
      var        call = this.finishCall(callee, arguments, loop, pos)
      break if !call

      call = this.make.directIfReference(call)
      break if !call

      const        rhs = call.type.isaTuple()
      const lastIsBool = rhs.scope.symbols.last().instance.type.isBool() if rhs && rhs.scope.symbols.length
      if !rhs || rhs.scope.symbols.length < 2 || !lastIsBool {
        this.cberr(pos, call) with {
          println("expected rhs of 'each' statement to be a tuple of at least 2 items with the last \
            being of type #{ast.tyBool}\r\n\t\
            â†’ found: #{it.type}")
        }
        this.throwAway(call)
        break
      }

      const label = this.make.label(pos)
         label.id = ++function.labelIds

      // self.ioresume âŸµ label.id
      this.setIoResume(function, label, loop, pos)

      // self.ioreturn âŸµ call; retval âŸµ *&self.ioreturn
      this.setIoReturnValueWithValueOfYieldFrom(function, call, loop, pos)

      // if self.ioawaiter { ... }
      this.advanceAwaiter(function, loop, pos)

      // yield
      this.createYield(function, label, loop, pos)

      // if self.iostopped { ... }
      this.exitIoIfStopped(function, loop, pos)

      // if self.ioreturn.done { self.exitReason âŸµ ExitReason.Break }
      const    tuple = function.fnreturn.isaReference().pointee.isaTuple()
      const ioreturn = this.make.io(function, this.ids.kw_ioreturn, pos)
      if const  done = this.findMember(ioreturn, tuple.scope.symbols.last().name, loop, pos, pos) {
        const ifnode = this.make.ifStmt(loop, pos, withExit = false, withExitInParent = false)
        loop.appendStatement(ifnode)
        ifnode.condition = this.make.logicalIs(done, pos)
        const rsvd3 = this.enterScope(ifnode, loop)
        this.setExitReason(ExitReason.Break, ifnode, pos)
        this.leaveScope(rsvd3)
      }

      // loopExit: ...deferreds...
      this.visitDeferredsOfLoop(loop, increment = ast.Node*{})
      this.leaveScope(rsvd2)
      // } end loop

      break
    }

    if !taken {
      block.appendStatement(loop.entry)
      block.appendStatement(loop)
      const rsvd2 = this.enterScope(loop, block)
      this.visitDeferredsOfLoop(loop, increment = ast.Node*{})
      this.leaveScope(rsvd2)
    }

    this.visitDeferredsOfBlock(block)
    this.leaveScope(rsvd1)
    outer.appendStatement(block)
  }


  fn bindAwaitStatement(this, template, scope):void {
    assert 0
  }


  fn bindAwaitExpression(this, template, scope): ast.Node* {
    assert 0
  }


  fn setIoResume(this, function, label, scope, pos) {
    /* self.ioresume âŸµ label.id */
    scope.appendStatement(
        this.finishAssignment(
            this.make.io(function, this.ids.kw_ioresume, pos),
            this.make.int(label.id, pos),
            scope,
            pos
          )
      )
  }


  fn setIoReturnValueWithValueOfYieldFrom(this, function, val, scope, pos):void {
    /*  Translation ðŸ¡“
          self.ioreturn âŸµ value
                 retval âŸµ &*self.ioreturn
    */
    var value = this.expectValue(val, scope, initializeIfType = true)
    return if !value

    const generator = function.generator

    this.setIoReturnType(function, value.type)

    const type = function.fnreturn

    // self.ioreturn âŸµ val
    const ioreturn = this.make.io(function, this.ids.kw_ioreturn, pos)
    scope.appendStatement(this.finishAssignment(ioreturn, value, scope, pos))

    // retval âŸµ &*self.ioreturn
    const  retval = this.make.retval(function, function.fnreturn, scope, pos)
    const     rhs = this.make.referenceOf(this.make.io(function, this.ids.kw_ioreturn, pos), pos)
    scope.appendStatement(this.finishDefinition(retval, rhs, scope, pos))
  }


  fn setIoReturnValue(this, function, val, done, scope, pos):void {
    /*  Translation ðŸ¡“
          self.ioreturn âŸµ ( value, done )
                 retval âŸµ &*self.ioreturn
    */
    var value = this.expectValue(val, scope, initializeIfType = true)
    return if !value

    const generator = function.generator
    var       tuple = ast.Object*{}

    // ( value, done )
    if const name = value is ast.Name {
      if tuple = name.symbol.instance is ast.Object {
        tuple = tuple.isaTuple()
      }
    }
    if !tuple {
      const symbol = this.make.tuple(scope, pos)
      tuple = symbol.instance as ast.Object*
      this.make.field(noModifiers, this.typer.emptyid, value, tuple.scope, pos)
      value = this.make.name(symbol, pos)
    }
    this.make.field(noModifiers, this.typer.emptyid, this.make.bool(done, pos), tuple.scope, pos)

    this.setIoReturnType(function, value.type)

    // self.ioreturn âŸµ ( value, done )
    var ioreturn = this.make.io(function, this.ids.kw_ioreturn, pos)
    scope.appendStatement(this.finishAssignment(ioreturn, value, scope, pos))

    // retval âŸµ &*self.ioreturn
    const  retval = this.make.retval(function, function.fnreturn, scope, pos)
    const     rhs = this.make.referenceOf(this.make.io(function, this.ids.kw_ioreturn, pos), pos)
    scope.appendStatement(this.finishDefinition(retval, rhs, scope, pos))
  }


  fn setIoReturnType(this, function, type) {
    const generator = function.generator
    var    ioreturn = ast.Symbol*{}
    const       idx = generator.scope.symbols.indexOf(this.ids.kw_ioreturn.hash)
    assert idx >= 0 && type.isaTuple()
    ioreturn = generator.scope.symbols.items[idx].value
    if function.fnreturn.isUnknown() {
      assert ioreturn.instance.type.isBool() && type.isaTuple()
      ioreturn.instance.type = type
           function.fnreturn = this.typer.types.referenceOf(type)
      this.finishGeneratorGetIoReturn(function.generator)
    } else {
      assert ioreturn.instance.type.isaTuple() && function.fnreturn.isaReference() &&
             function.fnreturn.isaReference().pointee == ioreturn.instance.type
    }
  }


  fn setIoReturnTypeFromFnReturn(this, function, template) {
    /*  Translation ðŸ¡“
          ( T, Bool )&
    */
    if var value = this.bind(template, function.scope) {
      if value.isaTypeName() {
        // ( T, Bool )
        var tuple = ast.Object*{}
        if const name = value is ast.Name {
          if tuple = name.symbol.instance is ast.Object {
             tuple = tuple.isaTuple()
          }
        }
        if !tuple {
          const symbol = this.make.tuple(function.scope, value.pos)
          tuple = symbol.instance as ast.Object*
          this.make.field(noModifiers, this.typer.emptyid, value, tuple.scope, value.pos)
          value = this.make.name(symbol, value.pos)
        }       
        if const found = this.find(function.scope, this.ids.get("Bool"), value.pos) {
          if found.instance is ast.Builtin && found.instance.type.isBool() {
            this.make.field(noModifiers, this.typer.emptyid, this.make.name(found, value.pos), tuple.scope,
              value.pos)
            this.setIoReturnType(function, value.type)
          } else this.cberr(value.pos, found) with {
            println("'Bool' should resolve to the type 'Bool'\r\n\t\
              â†’ not: #{it.type()}")
          }
        }
      } else this.cberr(value.pos, value) with {
        println("the return type of a generator must be a type\r\n\t\
          â†’ found: value of #{it.type}")
      }
      this.throwAway(value)
    }
  }


  fn resetIoReturnValue(this, function, pos):void {
    const scope = function.scope
    if function.fnreturn.isUnknown() {
      // (false, true)
      const symbol = this.make.tuple(scope, pos)
      const  tuple = symbol.instance as ast.Object*
      this.make.field(noModifiers, this.typer.emptyid, this.make.bool(false, pos), tuple.scope, pos)
      this.make.field(noModifiers, this.typer.emptyid, this.make.bool(true, pos), tuple.scope, pos)

      this.setIoReturnType(function, tuple.type)

      // self.ioreturn âŸµ ( false, true )
      const assign = this.finishAssignment(this.make.io(function, this.ids.kw_ioreturn, pos),
        this.make.name(symbol, pos), scope, pos)
      scope.appendStatement(assign)
    } else {
      var fnreturn = function.fnreturn.isaReference().pointee.isaTuple()
      const symbol = this.make.tuple(scope, pos)
      const  tuple = symbol.instance as ast.Object*

      // ( ... )
      for child in fnreturn.scope.symbols {
        this.make.field(noModifiers, this.typer.emptyid, this.make.zero(child.value.instance.type, pos),
          tuple.scope, pos)
      }

      // ( ..., true )
      const last = (tuple.scope.symbols.last().instance as ast.Field*).value is ast.Constant
      assert last && last.type.isBool()
      last.value.i64 = 1i64

      // self.ioreturn âŸµ ( ..., true )
      const assign = this.finishAssignment(this.make.io(function, this.ids.kw_ioreturn, pos),
        this.make.name(symbol, pos), scope, pos)
      scope.appendStatement(assign)
    }
    // retval âŸµ *&self.ioreturn    
    const  retval = this.make.retval(function, function.fnreturn, scope, pos)
    const     rhs = this.make.referenceOf(this.make.io(function, this.ids.kw_ioreturn, pos), pos)
    scope.appendStatement(this.finishDefinition(retval, rhs, scope, pos))
  }


  fn gotoAutoDeleteIfStopped(this, function, pos):void {
    const autoDelete = function.generatorLabels.exit
    const     ifnode = this.make.ifStmt(function.scope, pos, withExit = false, withExitInParent = false)
    const       rsvd = this.enterScope(ifnode, function.scope)
    function.scope.appendStatement(ifnode)

    // if self.iostopped
    ifnode.condition = this.make.logicalIs(this.make.io(function, this.ids.kw_iostopped, pos), pos)

    // self.ioresume âŸµ 0
    ifnode.appendStatement(
        this.finishAssignment(
            this.make.io(function, this.ids.kw_ioresume, pos),
            this.make.int(0, pos),
            ifnode,
            pos
          )
      )

    // goto autoDelete
    ifnode.appendStatement(this.make.goto(autoDelete, pos))

    this.leaveScope(rsvd)
  }


  fn lastAdvance(this, function, pos) {
    const autoDelete = function.generatorLabels.exit
    var       ifnode = this.make.ifStmt(function.scope, pos, withExit = false, withExitInParent = false)
    const      rsvd1 = this.enterScope(ifnode, function.scope)

    function.scope.appendStatement(ifnode)

    // if self.ioresume {
    ifnode.condition = this.make.logicalIs(this.make.io(function, this.ids.kw_ioresume, pos), pos)

    // self.ioresume âŸµ 0
    ifnode.appendStatement(
        this.finishAssignment(
            this.make.io(function, this.ids.kw_ioresume, pos),
            this.make.int(0, pos),
            ifnode,
            pos
          )
      )

    // if self.awaiter { ...next() }
    this.advanceAwaiter(function, ifnode, pos)

    // yield
    this.createYield(function, ast.Label*{}, ifnode, pos)

    // } end if self.ioresume
    this.leaveScope(rsvd1)

    // if self.awaiter { ...next(); yield }
    this.advanceAwaiter(function, function.scope, pos, insertYield = true)
  }


  fn finishAutoDeleteGenerator(this, function, pos) {
    const      scope = function.scope
    const     ioself = function.parameters.items[0]
    const autoDelete = function.generatorLabels.exit

    // autoDelete:
    scope.appendStatement(autoDelete)

    // mfree( self )
    if const call = this.callFree(this.make.name(ioself, pos), scope, pos) {
      // ( self = mfree( self ) ) if self.autoDelete
      scope.appendStatement(
          this.make.ifExpr(
                    pos = pos,
                 iftrue = this.finishAssignment(this.make.name(ioself, pos), call, scope, pos, ignoreConst = true),
              condition = this.make.logicalIs(this.make.io(function, this.ids.kw_autoDelete, pos), pos)
            )
          
        )
    }
  }


  fn advanceAwaiter(this, function, scope, pos, insertYield = false) {
    /*  Translation ðŸ¡“
          if self.ioawaiter {
                const local âŸµ self.awaiter as Generator*
            local.ioawaited âŸµ self as Void*
            local.next()
          }
    */
    const generator = function.generator
    const ioawaiter = this.make.io(function, this.ids.kw_ioawaiter, pos)
    const      type = this.typer.types.pointerOf(generator.type)

    // if self.ioawaiter
    const ifnode = this.make.ifStmt(scope, pos, withExit = false, withExitInParent = false)
    scope.appendStatement(ifnode)
    const rsvd = this.enterScope(ifnode, scope)
    ifnode.condition = this.make.logicalIs(ioawaiter, pos)

    // var local âŸµ self.awaiter as Generator*
    const local = this.make.local(noModifiers, this.ids.random("ioawaiter"), type, ifnode, pos, pos)
    ifnode.appendStatement(
        this.finishDefinition(
            this.make.name(local, pos),
            this.make.cast(this.make.copy(ioawaiter, pos), type, pos, isImplicit = false),
            ifnode,
            pos
          )
      )

    const idx = generator.scope.symbols.indexOf(this.ids.kw_ioawaited.hash)
    assert idx >= 0
    const ioawaited = generator.scope.symbols.items[idx].value

    // local.ioawaited âŸµ self as Void*
    ifnode.appendStatement(
        this.finishAssignment(
            this.make.member(this.make.name(local, pos), ioawaited, pos),
            this.make.cast(
                value = this.make.name(function.parameters.items[0], pos),
                 type = ioawaited.instance.type,
                  pos = pos,
                isImplicit = true
              ),
            ifnode,
            pos
          )
      )

    // local.next
    if const callee = this.findMember(this.make.name(local, pos), this.ids.kw_next, ifnode, pos, pos) {
      // ()
      const arguments = List(ast.Argument*){}
      // local.next()
      ifnode.appendStatement(this.finishCall(callee, arguments, ifnode, pos))

      // yield
      if insertYield {
        this.createYield(function, ast.Label*{}, ifnode, pos)
      }
    }

    this.leaveScope(rsvd)
  }


  fn exitIoIfStopped(this, function, scope, pos) {
    /*  Translation ðŸ¡“
          if self.iostopped {
            self.exitReason âŸµ ExitReason.Return
            goto exitInParent
          }
    */
    const ifnode = this.make.ifStmt(scope, pos, withExit = false, withExitInParent = true)
    scope.appendStatement(ifnode)
    const rsvd = this.enterScope(ifnode, scope)
    ifnode.condition = this.make.logicalIs(this.make.io(function, this.ids.kw_iostopped, pos), pos)
    this.setExitReason(ExitReason.Return, ifnode, pos)
    this.exitWithoutReason(ifnode, pos)
    this.leaveScope(rsvd)
  }


  fn createYield(this, function, label, scope, pos) {
    /*  Translation at yield point ðŸ¡“
            yield
          label:
    */

    /*  Translation at entry ðŸ¡“
          if self.ioresume == label.id {
            goto label
          }
    */
    scope.appendStatement(new ast.Yield{ pos = pos, isFollowedByALabel = label != null, type = ast.tyVoid })
    if label {
      scope.appendStatement(label)
      const entry = function.generatorLabels.entry
      const index = function.scope.statements.indexOf(entry) with entry, statement {
        return entry == statement
      }
      assert index >= 0

      const      top = entry.pos
      const   ifnode = this.make.ifStmt(function.scope, top, withExit = false, withExitInParent = false)
      const     rsvd = this.enterScope(ifnode, function.scope)
      function.scope.statements.insert(index, ifnode)
      ifnode.condition = this.make.binaryCondition(
          pos = top,
           op = Tok.Equal, 
          lhs = this.make.io(function, this.ids.kw_ioresume, top),
          rhs = this.make.int(label.id, top)
        )
      ifnode.appendStatement(
          this.make.goto(label, top)
        )
      this.leaveScope(rsvd)
    }
  }
}